#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SUBTURTLES_DIR="${PROJECT_DIR}/.subturtles"
DEFAULT_TIMEOUT="1h"
CRON_JOBS_FILE_REL="super_turtle/claude-telegram-bot/cron-jobs.json"
CRON_JOBS_FILE="${PROJECT_DIR}/${CRON_JOBS_FILE_REL}"

# Use subturtle venv if available, otherwise system python3
PYTHON="${SCRIPT_DIR}/.venv/bin/python3"
if [[ ! -x "$PYTHON" ]]; then
  PYTHON="python3"
fi

usage() {
  echo "Usage: ./super_turtle/subturtle/ctl <command> [name] [options]"
  echo ""
  echo "Commands:"
  echo "  start  [name] [--type TYPE] [--timeout DURATION] [--skill NAME ...]"
  echo "         Spawn a SubTurtle (default timeout: ${DEFAULT_TIMEOUT})"
  echo "         Types: slow (default), yolo, yolo-codex"
  echo "           slow       â€” Plan -> Groom -> Execute -> Review (4 calls/iter)"
  echo "           yolo       â€” Single Claude call per iteration (Ralph loop)"
  echo "           yolo-codex â€” Single Codex call per iteration (Ralph loop)"
  echo "         Skills: repeatable --skill flags load Claude Code skills (e.g. --skill frontend --skill testing)"
  echo "  spawn [name] [--type TYPE] [--timeout DURATION] [--state-file PATH|-] [--cron-interval DURATION] [--skill NAME ...]"
  echo "         Create workspace, seed CLAUDE.md from --state-file/stdin, start SubTurtle, and auto-register cron"
  echo "         Defaults: --type slow, --timeout ${DEFAULT_TIMEOUT}, --cron-interval 5m"
  echo "  stop   [name]                        Stop a SubTurtle gracefully"
  echo "  status [name]                        Check if running + time remaining"
  echo "  logs   [name]                        Tail a SubTurtle's log"
  echo "  list                                 List all SubTurtles and their status"
  echo ""
  echo "Timeout durations: 30m, 1h, 2h, 4h, etc. Default: ${DEFAULT_TIMEOUT}"
  echo "SubTurtles auto-terminate when their timeout expires."
  echo ""
  echo "IMPORTANT: CLAUDE.md must exist in the workspace before starting."
  echo "The meta agent writes it â€” ctl does NOT auto-seed from root."
  echo ""
  echo "Each SubTurtle gets its own workspace at .subturtles/<name>/ with"
  echo "its own CLAUDE.md, AGENTS.md symlink, PID file, and log file."
  exit 1
}

# Resolve the workspace directory for a named SubTurtle
workspace_dir() {
  local name="${1:-default}"
  echo "${SUBTURTLES_DIR}/${name}"
}

pid_file()  { echo "$(workspace_dir "$1")/subturtle.pid"; }
log_file()  { echo "$(workspace_dir "$1")/subturtle.log"; }
meta_file() { echo "$(workspace_dir "$1")/subturtle.meta"; }
tunnel_url_file() { echo "$(workspace_dir "$1")/.tunnel-url"; }

# --- Duration helpers ---

# Parse a human duration string (30m, 1h, 2h, 4h) into seconds.
# Falls back to raw seconds if no suffix.
parse_duration() {
  local input="$1"
  local suffix="${input: -1}"

  # Check if last char is a known unit suffix
  case "$suffix" in
    m|M|h|H|d|D)
      local num="${input%[mMhHdD]}"
      if ! [[ "$num" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      case "$suffix" in
        m|M) echo $(( num * 60 )) ;;
        h|H) echo $(( num * 3600 )) ;;
        d|D) echo $(( num * 86400 )) ;;
      esac
      ;;
    *)
      # No suffix â€” treat entire input as raw seconds
      if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      echo "$input"
      ;;
  esac
}

# Format seconds into a human-readable string (e.g. "1h 23m", "45m", "2m").
format_duration() {
  local secs="$1"
  if (( secs < 0 )); then secs=0; fi
  local h=$(( secs / 3600 ))
  local m=$(( (secs % 3600) / 60 ))
  if (( h > 0 )); then
    echo "${h}h ${m}m"
  else
    echo "${m}m"
  fi
}

# Read the .meta file into shell variables: SPAWNED_AT, TIMEOUT_SECONDS, WATCHDOG_PID.
# Uses grep to extract known keys only â€” never sources the file directly.
# Returns 1 if meta file doesn't exist.
read_meta() {
  local mf
  mf="$(meta_file "$1")"
  if [[ -f "$mf" ]]; then
    SPAWNED_AT="$(grep -m1 '^SPAWNED_AT=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    TIMEOUT_SECONDS="$(grep -m1 '^TIMEOUT_SECONDS=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    WATCHDOG_PID="$(grep -m1 '^WATCHDOG_PID=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    LOOP_TYPE="$(grep -m1 '^LOOP_TYPE=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    SKILLS="$(grep -m1 '^SKILLS=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    CRON_JOB_ID="$(grep -m1 '^CRON_JOB_ID=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    return 0
  fi
  return 1
}

# Compute seconds remaining before timeout. Negative = overdue.
time_remaining() {
  local name="$1"
  SPAWNED_AT="" TIMEOUT_SECONDS=""
  if ! read_meta "$name"; then
    echo ""
    return
  fi
  if [[ -z "$SPAWNED_AT" || -z "$TIMEOUT_SECONDS" ]]; then
    echo ""
    return
  fi
  local now elapsed remaining
  now="$(date +%s)"
  elapsed=$(( now - SPAWNED_AT ))
  remaining=$(( TIMEOUT_SECONDS - elapsed ))
  echo "$remaining"
}

# Format a time-remaining value for display.
format_time_remaining() {
  local remaining="$1"
  if [[ -z "$remaining" ]]; then
    echo "no timeout"
    return
  fi
  if (( remaining <= 0 )); then
    echo "OVERDUE"
  else
    echo "$(format_duration "$remaining") left"
  fi
}

ensure_workspace() {
  local name="${1:-default}"
  local ws
  ws="$(workspace_dir "$name")"

  mkdir -p "$ws"

  # CLAUDE.md must be pre-written by the meta agent before spawning
  if [[ ! -f "$ws/CLAUDE.md" ]]; then
    echo "[subturtle:${name}] ERROR: CLAUDE.md not found in workspace (${ws}/CLAUDE.md)" >&2
    echo "[subturtle:${name}] The meta agent must write CLAUDE.md before starting a SubTurtle." >&2
    exit 1
  fi

  # Create AGENTS.md symlink if missing
  if [[ ! -L "$ws/AGENTS.md" ]]; then
    ln -sf CLAUDE.md "$ws/AGENTS.md"
  fi
}

is_running() {
  local pf
  pf="$(pid_file "$1")"
  if [[ -f "$pf" ]]; then
    local pid
    pid="$(cat "$pf")"
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

read_pid() {
  cat "$(pid_file "$1")" 2>/dev/null || echo ""
}

do_start() {
  local name="${1:-default}"
  local timeout_str="${DEFAULT_TIMEOUT}"
  local loop_type="slow"
  local -a skills=()

  # Parse --timeout, --type, and --skill flags from remaining args
  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout_str="${2:?missing timeout value}"; shift 2 ;;
      --type)    loop_type="${2:?missing type value}"; shift 2 ;;
      --skill)   skills+=("${2:?missing skill name}"); shift 2 ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  # Validate loop type
  case "$loop_type" in
    slow|yolo|yolo-codex) ;;
    *) echo "ERROR: unknown SubTurtle type '${loop_type}' (must be: slow, yolo, yolo-codex)" >&2; exit 1 ;;
  esac

  local timeout_secs
  timeout_secs="$(parse_duration "$timeout_str")" || exit 1

  # Convert skills array to JSON. Guard empty arrays for bash + nounset compatibility.
  local skills_json="[]"
  if (( ${#skills[@]} > 0 )); then
    skills_json="$(
      printf '%s\n' "${skills[@]}" | "$PYTHON" -c 'import sys, json; print(json.dumps([line.strip() for line in sys.stdin if line.strip()]))' 2>/dev/null || echo '[]'
    )"
  fi

  ensure_workspace "$name"

  if is_running "$name"; then
    echo "[subturtle:${name}] already running (PID $(read_pid "$name"))"
    exit 0
  fi

  local pf lf mf ws
  pf="$(pid_file "$name")"
  lf="$(log_file "$name")"
  mf="$(meta_file "$name")"
  ws="$(workspace_dir "$name")"

  rm -f "$pf" "$mf"

  echo "[subturtle:${name}] spawning (type: ${loop_type}, timeout: ${timeout_str})..."
  echo "[subturtle:${name}] workspace: ${ws}"
  echo "[subturtle:${name}] log: ${lf}"

  # Spawn the SubTurtle module in a new session via start_new_session=True.
  # This calls os.setsid() in the child, giving it its own session
  # and process group â€” unreachable by the parent's group signals.
  # The launcher exits immediately; child process is orphaned to PID 1.
  "$PYTHON" -c "
import subprocess, sys, os, json

pid_file   = sys.argv[1]
log_file   = sys.argv[2]
python     = sys.argv[3]
cwd        = sys.argv[4]
state_dir  = sys.argv[5]
name       = sys.argv[6]
loop_type  = sys.argv[7]
skills_json = sys.argv[8] if len(sys.argv) > 8 else '[]'

try:
    skills = json.loads(skills_json)
except (ValueError, TypeError):
    skills = []

env = os.environ.copy()
# Strip Claude Code session vars so child can spawn its own claude processes
for key in list(env):
    if key.startswith('CLAUDECODE'):
        del env[key]

log_fd = open(log_file, 'w')
cmd = [python, '-u', '-m', 'super_turtle.subturtle', '--state-dir', state_dir, '--name', name, '--type', loop_type]
if skills:
    cmd.extend(['--skills'] + skills)

proc = subprocess.Popen(
    cmd,
    cwd=cwd,
    stdin=subprocess.DEVNULL,
    stdout=log_fd,
    stderr=log_fd,
    start_new_session=True,
    env=env,
)
log_fd.close()

with open(pid_file, 'w') as f:
    f.write(str(proc.pid))

print(f'[subturtle:{name}] spawned as {loop_type} (PID {proc.pid})')
" "$pf" "$lf" "$PYTHON" "$PROJECT_DIR" "$ws" "$name" "$loop_type" "$skills_json"

  # Read back the PID we just wrote
  local turtle_pid
  if [[ ! -f "$pf" ]]; then
    echo "[subturtle:${name}] ERROR: spawn failed â€” no PID file written" >&2
    exit 1
  fi
  turtle_pid="$(cat "$pf")"

  # Write metadata (spawn time + timeout + skills)
  local spawned_at
  spawned_at="$(date +%s)"
  cat > "$mf" <<METAEOF
SPAWNED_AT=${spawned_at}
TIMEOUT_SECONDS=${timeout_secs}
LOOP_TYPE=${loop_type}
SKILLS=${skills_json}
METAEOF

  # Spawn watchdog: sleeps for timeout, then kills the sub-turtle.
  # The watchdog is a fire-and-forget background process â€” no polling overhead.
  # disown ensures it survives if the launching terminal closes.
  (
    sleep "$timeout_secs"
    if kill -0 "$turtle_pid" 2>/dev/null; then
      echo "[subturtle:${name}] TIMEOUT ($(format_duration "$timeout_secs")) â€” sending SIGTERM to PID ${turtle_pid}" >> "$lf"
      kill "$turtle_pid" 2>/dev/null || true
      sleep 5
      if kill -0 "$turtle_pid" 2>/dev/null; then
        echo "[subturtle:${name}] SIGTERM didn't work â€” sending SIGKILL" >> "$lf"
        kill -9 "$turtle_pid" 2>/dev/null || true
      fi
      rm -f "$pf" "$mf"
      echo "[subturtle:${name}] timed out and killed" >> "$lf"
    fi
  ) &
  local watchdog_pid=$!
  disown "$watchdog_pid"

  # Append watchdog PID to meta
  echo "WATCHDOG_PID=${watchdog_pid}" >> "$mf"

  echo "[subturtle:${name}] watchdog armed (${timeout_str}, PID ${watchdog_pid})"
}

register_spawn_cron_job() {
  local name="$1"
  local interval_ms="$2"
  local cron_jobs_file="$CRON_JOBS_FILE"

  "$PYTHON" - "$cron_jobs_file" "$name" "$interval_ms" <<'PY'
import datetime
import json
import secrets
import sys
from pathlib import Path

cron_jobs_path = Path(sys.argv[1])
name = sys.argv[2]
interval_ms = int(sys.argv[3])

prompt = (
    f"[SILENT CHECK-IN] Check SubTurtle {name}: run `./super_turtle/subturtle/ctl status {name}`, "
    f"inspect `.subturtles/{name}/CLAUDE.md`, and review `git log --oneline -10`.\n"
    "Rules: Do NOT message the user unless one of these conditions is met:\n"
    f"- ðŸŽ‰ SubTurtle completed all backlog items -> stop SubTurtle {name} and report what shipped\n"
    f"- âš ï¸ SubTurtle appears stuck (no meaningful progress across 2+ checks) -> stop it, diagnose, and report\n"
    "- âŒ SubTurtle errored, crashed, or is otherwise broken -> report the error clearly\n"
    "- ðŸš€ New milestone reached (significant backlog progress) -> send one brief update\n"
    "If SubTurtle is progressing normally without notable events, respond with only: [SILENT]"
)

jobs = []
if cron_jobs_path.exists():
    raw = cron_jobs_path.read_text(encoding="utf-8").strip()
    if raw:
        parsed = json.loads(raw)
        if not isinstance(parsed, list):
            raise ValueError("cron-jobs.json must contain a JSON array")
        jobs = parsed

existing_ids = {
    str(job.get("id"))
    for job in jobs
    if isinstance(job, dict) and "id" in job
}

job_id = ""
for _ in range(32):
    candidate = secrets.token_hex(3)
    if candidate not in existing_ids:
        job_id = candidate
        break
if not job_id:
    raise RuntimeError("failed to generate unique cron job id")

now_ms = int(datetime.datetime.now(datetime.timezone.utc).timestamp() * 1000)
job = {
    "id": job_id,
    "prompt": prompt,
    "silent": True,
    "type": "recurring",
    "fire_at": now_ms + interval_ms,
    "interval_ms": interval_ms,
    "created_at": datetime.datetime.now(datetime.timezone.utc)
    .replace(microsecond=0)
    .isoformat()
    .replace("+00:00", "Z"),
}

jobs.append(job)
cron_jobs_path.write_text(json.dumps(jobs, indent=2) + "\n", encoding="utf-8")
print(job_id)
PY
}

remove_spawn_cron_job() {
  local cron_job_id="$1"
  local cron_jobs_file="$CRON_JOBS_FILE"

  "$PYTHON" - "$cron_jobs_file" "$cron_job_id" <<'PY'
import json
import sys
from pathlib import Path

cron_jobs_path = Path(sys.argv[1])
cron_job_id = sys.argv[2]

if not cron_jobs_path.exists():
    raise FileNotFoundError(f"cron jobs file not found: {cron_jobs_path}")

raw = cron_jobs_path.read_text(encoding="utf-8").strip()
jobs = []
if raw:
    parsed = json.loads(raw)
    if not isinstance(parsed, list):
        raise ValueError("cron-jobs.json must contain a JSON array")
    jobs = parsed

new_jobs = []
removed = False
for job in jobs:
    if isinstance(job, dict) and str(job.get("id")) == cron_job_id:
        removed = True
        continue
    new_jobs.append(job)

if not removed:
    raise RuntimeError(f"cron job id not found: {cron_job_id}")

cron_jobs_path.write_text(json.dumps(new_jobs, indent=2) + "\n", encoding="utf-8")
PY
}

do_spawn() {
  local name="${1:-default}"
  local timeout_str="${DEFAULT_TIMEOUT}"
  local loop_type="slow"
  local cron_interval="5m"
  local state_file=""
  local -a skills=()

  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout_str="${2:?missing timeout value}"; shift 2 ;;
      --type)    loop_type="${2:?missing type value}"; shift 2 ;;
      --state-file) state_file="${2:?missing state file path}"; shift 2 ;;
      --cron-interval) cron_interval="${2:?missing cron interval}"; shift 2 ;;
      --skill)   skills+=("${2:?missing skill name}"); shift 2 ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local cron_interval_secs
  cron_interval_secs="$(parse_duration "$cron_interval")" || exit 1
  if (( cron_interval_secs <= 0 )); then
    echo "[subturtle:${name}] ERROR: --cron-interval must be greater than zero" >&2
    exit 1
  fi
  local cron_interval_ms=$(( cron_interval_secs * 1000 ))

  local ws
  ws="$(workspace_dir "$name")"
  mkdir -p "$ws"

  if [[ -n "$state_file" ]]; then
    if [[ "$state_file" == "-" ]]; then
      if ! cat > "$ws/CLAUDE.md"; then
        echo "[subturtle:${name}] ERROR: failed reading state from stdin" >&2
        exit 1
      fi
    else
      if [[ ! -f "$state_file" ]]; then
        echo "[subturtle:${name}] ERROR: state file not found: ${state_file}" >&2
        exit 1
      fi
      cp "$state_file" "$ws/CLAUDE.md"
    fi
  elif [[ ! -t 0 ]]; then
    if ! cat > "$ws/CLAUDE.md"; then
      echo "[subturtle:${name}] ERROR: failed reading state from stdin" >&2
      exit 1
    fi
  else
    echo "[subturtle:${name}] ERROR: missing state input (use --state-file PATH or pipe stdin)" >&2
    exit 1
  fi

  ln -sf CLAUDE.md "$ws/AGENTS.md"

  local -a start_args=("$name" --type "$loop_type" --timeout "$timeout_str")
  local skill
  if (( ${#skills[@]} > 0 )); then
    for skill in "${skills[@]}"; do
      start_args+=(--skill "$skill")
    done
  fi
  do_start "${start_args[@]}"

  local cron_job_id
  if ! cron_job_id="$(register_spawn_cron_job "$name" "$cron_interval_ms")"; then
    echo "[subturtle:${name}] ERROR: failed to register cron job in ${CRON_JOBS_FILE_REL}" >&2
    echo "[subturtle:${name}] stopping SubTurtle because cron registration failed" >&2
    if is_running "$name"; then
      do_stop "$name" >/dev/null 2>&1 || true
    fi
    exit 1
  fi

  echo "CRON_JOB_ID=${cron_job_id}" >> "$(meta_file "$name")"

  echo "[subturtle:${name}] cron registered (${cron_job_id}, every ${cron_interval})"
}

do_stop() {
  local name="${1:-default}"

  # Remove recurring supervision cron before stopping the process.
  CRON_JOB_ID=""
  if read_meta "$name" && [[ -n "${CRON_JOB_ID:-}" ]]; then
    if remove_spawn_cron_job "$CRON_JOB_ID"; then
      echo "[subturtle:${name}] cron job ${CRON_JOB_ID} removed"
    else
      echo "[subturtle:${name}] WARNING: failed to remove cron job ${CRON_JOB_ID}" >&2
    fi
  fi

  # Kill the watchdog first so it doesn't fire after manual stop
  WATCHDOG_PID=""
  if read_meta "$name" && [[ -n "${WATCHDOG_PID:-}" ]]; then
    kill "$WATCHDOG_PID" 2>/dev/null || true
  fi

  if ! is_running "$name"; then
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
    exit 0
  fi

  local pid
  pid="$(read_pid "$name")"
  echo "[subturtle:${name}] stopping (PID ${pid})..."

  kill "$pid" 2>/dev/null || true

  local i
  for i in $(seq 1 10); do
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "[subturtle:${name}] stopped"
      rm -f "$(pid_file "$name")" "$(meta_file "$name")"
      return
    fi
    sleep 1
  done

  echo "[subturtle:${name}] sending SIGKILL..."
  kill -9 "$pid" 2>/dev/null || true
  rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  echo "[subturtle:${name}] killed"
}

do_status() {
  local name="${1:-default}"

  if is_running "$name"; then
    local pid remaining_secs
    pid="$(read_pid "$name")"

    remaining_secs="$(time_remaining "$name")"

    # Read meta for type and skills info (always attempt)
    LOOP_TYPE=""
    SKILLS=""
    read_meta "$name" || true
    local type_info="${LOOP_TYPE:-slow}"

    # Build the status line
    local time_info=""
    if [[ -n "$remaining_secs" && -n "$SPAWNED_AT" ]]; then
      local now elapsed
      now="$(date +%s)"
      elapsed=$(( now - SPAWNED_AT ))
      time_info=" â€” $(format_duration "$elapsed") elapsed, $(format_time_remaining "$remaining_secs")"
    fi

    echo "[subturtle:${name}] running as ${type_info} (PID ${pid})${time_info}"

    # Show skills if any
    if [[ -n "$SKILLS" && "$SKILLS" != "[]" ]]; then
      echo "[subturtle:${name}] skills: ${SKILLS}"
    fi

    ps -o pid,ppid,pgid,sess,state,etime,command -p "$pid" 2>/dev/null || true

    # Show tunnel URL if it exists
    local tunnel_file
    tunnel_file="$(tunnel_url_file "$name")"
    if [[ -f "$tunnel_file" ]]; then
      local tunnel_url
      tunnel_url="$(cat "$tunnel_file")"
      echo "[subturtle:${name}] tunnel URL: ${tunnel_url}"
    fi
  else
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  fi
}

do_logs() {
  local name="${1:-default}"
  local lf
  lf="$(log_file "$name")"

  if [[ ! -f "$lf" ]]; then
    echo "[subturtle:${name}] no log file found at ${lf}"
    exit 1
  fi
  tail -n "${LINES:-50}" -f "$lf"
}

do_list() {
  if [[ ! -d "$SUBTURTLES_DIR" ]]; then
    echo "No SubTurtles found."
    return
  fi

  local found=0
  for ws in "$SUBTURTLES_DIR"/*/; do
    [[ -d "$ws" ]] || continue
    local name
    name="$(basename "$ws")"
    found=1

    local status_str="stopped"
    local pid_str=""
    local time_str=""
    local type_str=""
    local skills_str=""
    local pf="${ws}subturtle.pid"
    if [[ -f "$pf" ]]; then
      local pid
      pid="$(cat "$pf")"
      if kill -0 "$pid" 2>/dev/null; then
        status_str="running"
        pid_str=" (PID ${pid})"

        # Show time remaining and loop type from meta
        local remaining_secs
        remaining_secs="$(time_remaining "$name")"
        time_str="$(format_time_remaining "$remaining_secs")"

        LOOP_TYPE=""
        SKILLS=""
        read_meta "$name" || true
        type_str="${LOOP_TYPE:-slow}"
        if [[ -n "$SKILLS" && "$SKILLS" != "[]" ]]; then
          skills_str=" [skills: ${SKILLS}]"
        fi
      fi
    fi

    # Read current task from this SubTurtle's CLAUDE.md
    local task="(no task)"
    if [[ -f "${ws}CLAUDE.md" ]]; then
      task="$(
        awk '
          /^# Current task$/ { in_current=1; next }
          in_current && /^# / { exit }
          in_current {
            line = $0
            sub(/[[:space:]]*<- current[[:space:]]*$/, "", line)
            if (line ~ /[^[:space:]]/) {
              print line
              exit
            }
          }
        ' "${ws}CLAUDE.md"
      )"
      [[ -z "$task" ]] && task="(no task)"
    fi

    if [[ -n "$time_str" ]]; then
      printf "  %-15s %-8s %-12s %-14s %-14s %s%s\n" "$name" "$status_str" "$type_str" "$pid_str" "$time_str" "$task" "$skills_str"
    else
      printf "  %-15s %-8s %-12s %-14s %-14s %s%s\n" "$name" "$status_str" "" "$pid_str" "" "$task" "$skills_str"
    fi

    # Show tunnel URL if it exists
    local tunnel_file
    tunnel_file="$(tunnel_url_file "$name")"
    if [[ -f "$tunnel_file" ]]; then
      local tunnel_url
      tunnel_url="$(cat "$tunnel_file")"
      printf "  %-15s â†’ %s\n" "" "$tunnel_url"
    fi
  done

  if [[ $found -eq 0 ]]; then
    echo "No SubTurtles found."
  fi
}

# --- Main ---
if [[ $# -lt 1 ]]; then
  usage
fi

CMD="$1"
shift

case "$CMD" in
  start)
    # Optional first positional arg is name. If first arg is a flag, use default.
    NAME="default"
    if [[ $# -gt 0 && "$1" != --* ]]; then
      NAME="$1"
      shift
    fi
    do_start "$NAME" "$@"
    ;;
  spawn)
    # Optional first positional arg is name. If first arg is a flag, use default.
    NAME="default"
    if [[ $# -gt 0 && "$1" != --* ]]; then
      NAME="$1"
      shift
    fi
    do_spawn "$NAME" "$@"
    ;;
  stop)   do_stop "${1:-default}" ;;
  status) do_status "${1:-default}" ;;
  logs)   do_logs "${1:-default}" ;;
  list)   do_list ;;
  *)      usage ;;
esac
