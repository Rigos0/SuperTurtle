#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SUBTURTLES_DIR="${PROJECT_DIR}/.subturtles"
DEFAULT_TIMEOUT="1h"

# Use subturtle venv if available, otherwise system python3
PYTHON="${SCRIPT_DIR}/.venv/bin/python3"
if [[ ! -x "$PYTHON" ]]; then
  PYTHON="python3"
fi

usage() {
  echo "Usage: ./super_turtle/subturtle/ctl <command> [name] [options]"
  echo ""
  echo "Commands:"
  echo "  start  [name] [--timeout DURATION]   Spawn a SubTurtle (default timeout: ${DEFAULT_TIMEOUT})"
  echo "  stop   [name]                        Stop a SubTurtle gracefully"
  echo "  status [name]                        Check if running + time remaining"
  echo "  logs   [name]                        Tail a SubTurtle's log"
  echo "  list                                 List all SubTurtles and their status"
  echo ""
  echo "Timeout durations: 30m, 1h, 2h, 4h, etc. Default: ${DEFAULT_TIMEOUT}"
  echo "SubTurtles auto-terminate when their timeout expires."
  echo ""
  echo "Each SubTurtle gets its own workspace at .subturtles/<name>/ with"
  echo "its own CLAUDE.md, AGENTS.md symlink, PID file, and log file."
  exit 1
}

# Resolve the workspace directory for a named SubTurtle
workspace_dir() {
  local name="${1:-default}"
  echo "${SUBTURTLES_DIR}/${name}"
}

pid_file()  { echo "$(workspace_dir "$1")/subturtle.pid"; }
log_file()  { echo "$(workspace_dir "$1")/subturtle.log"; }
meta_file() { echo "$(workspace_dir "$1")/subturtle.meta"; }

# --- Duration helpers ---

# Parse a human duration string (30m, 1h, 2h, 4h) into seconds.
# Falls back to raw seconds if no suffix.
parse_duration() {
  local input="$1"
  local suffix="${input: -1}"

  # Check if last char is a known unit suffix
  case "$suffix" in
    m|M|h|H|d|D)
      local num="${input%[mMhHdD]}"
      if ! [[ "$num" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      case "$suffix" in
        m|M) echo $(( num * 60 )) ;;
        h|H) echo $(( num * 3600 )) ;;
        d|D) echo $(( num * 86400 )) ;;
      esac
      ;;
    *)
      # No suffix — treat entire input as raw seconds
      if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      echo "$input"
      ;;
  esac
}

# Format seconds into a human-readable string (e.g. "1h 23m", "45m", "2m").
format_duration() {
  local secs="$1"
  if (( secs < 0 )); then secs=0; fi
  local h=$(( secs / 3600 ))
  local m=$(( (secs % 3600) / 60 ))
  if (( h > 0 )); then
    echo "${h}h ${m}m"
  else
    echo "${m}m"
  fi
}

# Read the .meta file into shell variables: SPAWNED_AT, TIMEOUT_SECONDS, WATCHDOG_PID.
# Uses grep to extract known keys only — never sources the file directly.
# Returns 1 if meta file doesn't exist.
read_meta() {
  local mf
  mf="$(meta_file "$1")"
  if [[ -f "$mf" ]]; then
    SPAWNED_AT="$(grep -m1 '^SPAWNED_AT=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    TIMEOUT_SECONDS="$(grep -m1 '^TIMEOUT_SECONDS=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    WATCHDOG_PID="$(grep -m1 '^WATCHDOG_PID=' "$mf" 2>/dev/null | cut -d= -f2)" || true
    return 0
  fi
  return 1
}

# Compute seconds remaining before timeout. Negative = overdue.
time_remaining() {
  local name="$1"
  SPAWNED_AT="" TIMEOUT_SECONDS=""
  if ! read_meta "$name"; then
    echo ""
    return
  fi
  if [[ -z "$SPAWNED_AT" || -z "$TIMEOUT_SECONDS" ]]; then
    echo ""
    return
  fi
  local now elapsed remaining
  now="$(date +%s)"
  elapsed=$(( now - SPAWNED_AT ))
  remaining=$(( TIMEOUT_SECONDS - elapsed ))
  echo "$remaining"
}

# Format a time-remaining value for display.
format_time_remaining() {
  local remaining="$1"
  if [[ -z "$remaining" ]]; then
    echo "no timeout"
    return
  fi
  if (( remaining <= 0 )); then
    echo "OVERDUE"
  else
    echo "$(format_duration "$remaining") left"
  fi
}

ensure_workspace() {
  local name="${1:-default}"
  local ws
  ws="$(workspace_dir "$name")"

  mkdir -p "$ws"

  # Create CLAUDE.md if it doesn't exist yet — seed from root if available
  if [[ ! -f "$ws/CLAUDE.md" ]]; then
    if [[ -f "$PROJECT_DIR/CLAUDE.md" ]]; then
      cp "$PROJECT_DIR/CLAUDE.md" "$ws/CLAUDE.md"
      echo "[subturtle:${name}] seeded CLAUDE.md from project root"
    else
      cat > "$ws/CLAUDE.md" <<'SEED'
# Current task

(no task set)

# End goal with specs

(not defined yet)

# Roadmap (Completed)

- (none yet)

# Roadmap (Upcoming)

- (none yet)

# Backlog

- [ ] Define end goal and first tasks <- current
- [ ] (placeholder 2)
- [ ] (placeholder 3)
- [ ] (placeholder 4)
- [ ] (placeholder 5)
SEED
      echo "[subturtle:${name}] created empty CLAUDE.md"
    fi
  fi

  # Create AGENTS.md symlink if missing
  if [[ ! -L "$ws/AGENTS.md" ]]; then
    ln -sf CLAUDE.md "$ws/AGENTS.md"
  fi
}

is_running() {
  local pf
  pf="$(pid_file "$1")"
  if [[ -f "$pf" ]]; then
    local pid
    pid="$(cat "$pf")"
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

read_pid() {
  cat "$(pid_file "$1")" 2>/dev/null || echo ""
}

do_start() {
  local name="${1:-default}"
  local timeout_str="${DEFAULT_TIMEOUT}"

  # Parse --timeout flag from remaining args
  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout_str="${2:?missing timeout value}"; shift 2 ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local timeout_secs
  timeout_secs="$(parse_duration "$timeout_str")" || exit 1

  ensure_workspace "$name"

  if is_running "$name"; then
    echo "[subturtle:${name}] already running (PID $(read_pid "$name"))"
    exit 0
  fi

  local pf lf mf ws
  pf="$(pid_file "$name")"
  lf="$(log_file "$name")"
  mf="$(meta_file "$name")"
  ws="$(workspace_dir "$name")"

  rm -f "$pf" "$mf"

  echo "[subturtle:${name}] spawning (timeout: ${timeout_str})..."
  echo "[subturtle:${name}] workspace: ${ws}"
  echo "[subturtle:${name}] log: ${lf}"

  # Spawn the SubTurtle module in a new session via start_new_session=True.
  # This calls os.setsid() in the child, giving it its own session
  # and process group — unreachable by the parent's group signals.
  # The launcher exits immediately; child process is orphaned to PID 1.
  "$PYTHON" -c "
import subprocess, sys, os

pid_file   = sys.argv[1]
log_file   = sys.argv[2]
python     = sys.argv[3]
cwd        = sys.argv[4]
state_dir  = sys.argv[5]
name       = sys.argv[6]

env = os.environ.copy()
# Strip Claude Code session vars so child can spawn its own claude processes
for key in list(env):
    if key.startswith('CLAUDECODE'):
        del env[key]

log_fd = open(log_file, 'w')
proc = subprocess.Popen(
    [python, '-u', '-m', 'super_turtle.subturtle', '--state-dir', state_dir, '--name', name],
    cwd=cwd,
    stdin=subprocess.DEVNULL,
    stdout=log_fd,
    stderr=log_fd,
    start_new_session=True,
    env=env,
)
log_fd.close()

with open(pid_file, 'w') as f:
    f.write(str(proc.pid))

print(f'[subturtle:{name}] spawned (PID {proc.pid})')
" "$pf" "$lf" "$PYTHON" "$PROJECT_DIR" "$ws" "$name"

  # Read back the PID we just wrote
  local turtle_pid
  if [[ ! -f "$pf" ]]; then
    echo "[subturtle:${name}] ERROR: spawn failed — no PID file written" >&2
    exit 1
  fi
  turtle_pid="$(cat "$pf")"

  # Write metadata (spawn time + timeout)
  local spawned_at
  spawned_at="$(date +%s)"
  cat > "$mf" <<METAEOF
SPAWNED_AT=${spawned_at}
TIMEOUT_SECONDS=${timeout_secs}
METAEOF

  # Spawn watchdog: sleeps for timeout, then kills the sub-turtle.
  # The watchdog is a fire-and-forget background process — no polling overhead.
  # disown ensures it survives if the launching terminal closes.
  (
    sleep "$timeout_secs"
    if kill -0 "$turtle_pid" 2>/dev/null; then
      echo "[subturtle:${name}] TIMEOUT ($(format_duration "$timeout_secs")) — sending SIGTERM to PID ${turtle_pid}" >> "$lf"
      kill "$turtle_pid" 2>/dev/null || true
      sleep 5
      if kill -0 "$turtle_pid" 2>/dev/null; then
        echo "[subturtle:${name}] SIGTERM didn't work — sending SIGKILL" >> "$lf"
        kill -9 "$turtle_pid" 2>/dev/null || true
      fi
      rm -f "$pf" "$mf"
      echo "[subturtle:${name}] timed out and killed" >> "$lf"
    fi
  ) &
  local watchdog_pid=$!
  disown "$watchdog_pid"

  # Append watchdog PID to meta
  echo "WATCHDOG_PID=${watchdog_pid}" >> "$mf"

  echo "[subturtle:${name}] watchdog armed (${timeout_str}, PID ${watchdog_pid})"
}

do_stop() {
  local name="${1:-default}"

  # Kill the watchdog first so it doesn't fire after manual stop
  WATCHDOG_PID=""
  if read_meta "$name" && [[ -n "${WATCHDOG_PID:-}" ]]; then
    kill "$WATCHDOG_PID" 2>/dev/null || true
  fi

  if ! is_running "$name"; then
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
    exit 0
  fi

  local pid
  pid="$(read_pid "$name")"
  echo "[subturtle:${name}] stopping (PID ${pid})..."

  kill "$pid" 2>/dev/null || true

  local i
  for i in $(seq 1 10); do
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "[subturtle:${name}] stopped"
      rm -f "$(pid_file "$name")" "$(meta_file "$name")"
      return
    fi
    sleep 1
  done

  echo "[subturtle:${name}] sending SIGKILL..."
  kill -9 "$pid" 2>/dev/null || true
  rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  echo "[subturtle:${name}] killed"
}

do_status() {
  local name="${1:-default}"

  if is_running "$name"; then
    local pid remaining_secs
    pid="$(read_pid "$name")"

    remaining_secs="$(time_remaining "$name")"

    # Build the status line
    local time_info=""
    if [[ -n "$remaining_secs" ]]; then
      SPAWNED_AT="" TIMEOUT_SECONDS=""
      read_meta "$name" || true
      local now elapsed
      now="$(date +%s)"
      elapsed=$(( now - SPAWNED_AT ))
      time_info=" — $(format_duration "$elapsed") elapsed, $(format_time_remaining "$remaining_secs")"
    fi

    echo "[subturtle:${name}] running (PID ${pid})${time_info}"
    ps -o pid,ppid,pgid,sess,state,etime,command -p "$pid" 2>/dev/null || true
  else
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  fi
}

do_logs() {
  local name="${1:-default}"
  local lf
  lf="$(log_file "$name")"

  if [[ ! -f "$lf" ]]; then
    echo "[subturtle:${name}] no log file found at ${lf}"
    exit 1
  fi
  tail -n "${LINES:-50}" -f "$lf"
}

do_list() {
  if [[ ! -d "$SUBTURTLES_DIR" ]]; then
    echo "No SubTurtles found."
    return
  fi

  local found=0
  for ws in "$SUBTURTLES_DIR"/*/; do
    [[ -d "$ws" ]] || continue
    local name
    name="$(basename "$ws")"
    found=1

    local status_str="stopped"
    local pid_str=""
    local time_str=""
    local pf="${ws}subturtle.pid"
    if [[ -f "$pf" ]]; then
      local pid
      pid="$(cat "$pf")"
      if kill -0 "$pid" 2>/dev/null; then
        status_str="running"
        pid_str=" (PID ${pid})"

        # Show time remaining from meta
        local remaining_secs
        remaining_secs="$(time_remaining "$name")"
        time_str="$(format_time_remaining "$remaining_secs")"
      fi
    fi

    # Read current task from this SubTurtle's CLAUDE.md
    local task="(no task)"
    if [[ -f "${ws}CLAUDE.md" ]]; then
      task="$(sed -n '/^# Current task/,/^# /{/^# /!p;}' "${ws}CLAUDE.md" | grep -v '^$' | head -1 | sed 's/ *<- current$//')"
      [[ -z "$task" ]] && task="(no task)"
    fi

    if [[ -n "$time_str" ]]; then
      printf "  %-15s %-8s%-14s %-14s %s\n" "$name" "$status_str" "$pid_str" "$time_str" "$task"
    else
      printf "  %-15s %-8s%-14s %-14s %s\n" "$name" "$status_str" "$pid_str" "" "$task"
    fi
  done

  if [[ $found -eq 0 ]]; then
    echo "No SubTurtles found."
  fi
}

# --- Main ---
if [[ $# -lt 1 ]]; then
  usage
fi

CMD="$1"
shift

case "$CMD" in
  start)
    # First positional arg is name, rest are flags (e.g. --timeout 2h)
    NAME="${1:-default}"
    if [[ $# -gt 0 ]]; then shift; fi
    do_start "$NAME" "$@"
    ;;
  stop)   do_stop "${1:-default}" ;;
  status) do_status "${1:-default}" ;;
  logs)   do_logs "${1:-default}" ;;
  list)   do_list ;;
  *)      usage ;;
esac
