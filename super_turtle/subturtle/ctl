#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SUBTURTLES_DIR="${PROJECT_DIR}/.subturtles"
DEFAULT_TIMEOUT="1h"
CRON_JOBS_FILE_REL="super_turtle/claude-telegram-bot/cron-jobs.json"
CRON_JOBS_FILE="${PROJECT_DIR}/${CRON_JOBS_FILE_REL}"
RUN_STATE_DIR_REL="super_turtle/state"
RUN_STATE_DIR="${PROJECT_DIR}/${RUN_STATE_DIR_REL}"
RUNS_JSONL_FILE="${RUN_STATE_DIR}/runs.jsonl"
HANDOFF_MD_FILE="${RUN_STATE_DIR}/handoff.md"
RUN_STATE_WRITER="${RUN_STATE_DIR}/run_state_writer.py"

# Use subturtle venv if available, otherwise system python3
PYTHON="${SCRIPT_DIR}/.venv/bin/python3"
if [[ ! -x "$PYTHON" ]]; then
  PYTHON="python3"
fi

usage() {
  echo "Usage: ./super_turtle/subturtle/ctl <command> [name] [options]"
  echo ""
  echo "Commands:"
  echo "  start  [name] [--type TYPE] [--timeout DURATION] [--skill NAME ...]"
  echo "         Spawn a SubTurtle (default timeout: ${DEFAULT_TIMEOUT})"
  echo "         Types: slow, yolo, yolo-codex (default), yolo-codex-spark"
  echo "           slow       â€” Plan -> Groom -> Execute -> Review (4 calls/iter)"
  echo "           yolo       â€” Single Claude call per iteration (Ralph loop)"
  echo "           yolo-codex â€” Single Codex call per iteration (Ralph loop)"
  echo "           yolo-codex-spark â€” Single Codex Spark call per iteration (Ralph loop)"
  echo "         Skills: repeatable --skill flags load Claude Code skills (e.g. --skill frontend --skill testing)"
  echo "  spawn [name] [--type TYPE] [--timeout DURATION] [--state-file PATH|-] [--cron-interval DURATION] [--skill NAME ...]"
  echo "         Create workspace, seed CLAUDE.md from --state-file/stdin, start SubTurtle, and auto-register cron"
  echo "         Defaults: --type yolo-codex, --timeout ${DEFAULT_TIMEOUT}, --cron-interval 10m"
  echo "  stop   [name]                        Stop a SubTurtle gracefully"
  echo "  status [name]                        Check if running + time remaining"
  echo "  logs   [name]                        Tail a SubTurtle's log"
  echo "  list   [--archived]                 List active SubTurtles (default) or archived SubTurtles"
  echo "  archive <name>                      Archive a stopped SubTurtle to .subturtles/.archive/<name>/"
  echo "  gc [--max-age DURATION]             Archive stopped SubTurtles older than max age (default: 1d)"
  echo "  reschedule-cron <name> <interval>   Update recurring cron interval (e.g. 1m, 5m)"
  echo ""
  echo "Timeout durations: 30m, 1h, 2h, 4h, etc. Default: ${DEFAULT_TIMEOUT}"
  echo "SubTurtles auto-terminate when their timeout expires."
  echo ""
  echo "IMPORTANT: CLAUDE.md must exist in the workspace before starting."
  echo "The meta agent writes it â€” ctl does NOT auto-seed from root."
  echo ""
  echo "Each SubTurtle gets its own workspace at .subturtles/<name>/ with"
  echo "its own CLAUDE.md, AGENTS.md symlink, PID file, and log file."
  exit 1
}

# Resolve the workspace directory for a named SubTurtle
workspace_dir() {
  local name="${1:-default}"
  echo "${SUBTURTLES_DIR}/${name}"
}

pid_file()  { echo "$(workspace_dir "$1")/subturtle.pid"; }
log_file()  { echo "$(workspace_dir "$1")/subturtle.log"; }
meta_file() { echo "$(workspace_dir "$1")/subturtle.meta"; }
tunnel_url_file() { echo "$(workspace_dir "$1")/.tunnel-url"; }

ensure_run_state_files() {
  mkdir -p "$RUN_STATE_DIR"

  if [[ ! -f "$RUNS_JSONL_FILE" ]]; then
    : > "$RUNS_JSONL_FILE"
  fi

  if [[ ! -f "$HANDOFF_MD_FILE" ]]; then
    cat > "$HANDOFF_MD_FILE" <<'EOF'
# SubTurtle Long-Run Handoff

Last updated: not yet

## Active Runs
- None yet.

## Recent Milestones
- None yet.

## Notes
- This summary is refreshed by supervision flows.
EOF
  fi
}

append_run_event() {
  local name="$1"
  local event="$2"
  local status="${3:-}"
  local -a writer_cmd=(
    "$PYTHON"
    "$RUN_STATE_WRITER"
    --state-dir
    "$RUN_STATE_DIR"
    append
    --run-name
    "$name"
    --event
    "$event"
  )

  if [[ -n "$status" ]]; then
    writer_cmd+=(--status "$status")
  fi

  if ! "${writer_cmd[@]}" >/dev/null 2>&1; then
    echo "[subturtle:${name}] WARNING: failed to append run state event '${event}'" >&2
  fi
}

# --- Duration helpers ---

# Parse a human duration string (30m, 1h, 2h, 4h) into seconds.
# Falls back to raw seconds if no suffix.
parse_duration() {
  local input="$1"
  local suffix="${input: -1}"

  # Check if last char is a known unit suffix
  case "$suffix" in
    m|M|h|H|d|D)
      local num="${input%[mMhHdD]}"
      if ! [[ "$num" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      case "$suffix" in
        m|M) echo $(( num * 60 )) ;;
        h|H) echo $(( num * 3600 )) ;;
        d|D) echo $(( num * 86400 )) ;;
      esac
      ;;
    *)
      # No suffix â€” treat entire input as raw seconds
      if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "ERROR: invalid duration '${input}'" >&2
        return 1
      fi
      echo "$input"
      ;;
  esac
}

# Format seconds into a human-readable string (e.g. "1h 23m", "45m", "2m").
format_duration() {
  local secs="$1"
  if (( secs < 0 )); then secs=0; fi
  local h=$(( secs / 3600 ))
  local m=$(( (secs % 3600) / 60 ))
  if (( h > 0 )); then
    echo "${h}h ${m}m"
  else
    echo "${m}m"
  fi
}

# Read the .meta file into shell variables: SPAWNED_AT, TIMEOUT_SECONDS, WATCHDOG_PID.
# Uses grep to extract known keys only â€” never sources the file directly.
# Returns 1 if meta file doesn't exist.
read_meta() {
  local mf
  mf="$(meta_file "$1")"
  if [[ -f "$mf" ]]; then
    SPAWNED_AT="$(grep -m1 '^SPAWNED_AT=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    TIMEOUT_SECONDS="$(grep -m1 '^TIMEOUT_SECONDS=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    WATCHDOG_PID="$(grep -m1 '^WATCHDOG_PID=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    LOOP_TYPE="$(grep -m1 '^LOOP_TYPE=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    SKILLS="$(grep -m1 '^SKILLS=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    CRON_JOB_ID="$(grep -m1 '^CRON_JOB_ID=' "$mf" 2>/dev/null | cut -d= -f2-)" || true
    return 0
  fi
  return 1
}

# Compute seconds remaining before timeout. Negative = overdue.
time_remaining() {
  local name="$1"
  SPAWNED_AT="" TIMEOUT_SECONDS=""
  if ! read_meta "$name"; then
    echo ""
    return
  fi
  if [[ -z "$SPAWNED_AT" || -z "$TIMEOUT_SECONDS" ]]; then
    echo ""
    return
  fi
  local now elapsed remaining
  now="$(date +%s)"
  elapsed=$(( now - SPAWNED_AT ))
  remaining=$(( TIMEOUT_SECONDS - elapsed ))
  echo "$remaining"
}

# Format a time-remaining value for display.
format_time_remaining() {
  local remaining="$1"
  if [[ -z "$remaining" ]]; then
    echo "no timeout"
    return
  fi
  if (( remaining <= 0 )); then
    echo "OVERDUE"
  else
    echo "$(format_duration "$remaining") left"
  fi
}

ensure_workspace() {
  local name="${1:-default}"
  local ws
  ws="$(workspace_dir "$name")"

  mkdir -p "$ws"

  # CLAUDE.md must be pre-written by the meta agent before spawning
  if [[ ! -f "$ws/CLAUDE.md" ]]; then
    echo "[subturtle:${name}] ERROR: CLAUDE.md not found in workspace (${ws}/CLAUDE.md)" >&2
    echo "[subturtle:${name}] The meta agent must write CLAUDE.md before starting a SubTurtle." >&2
    exit 1
  fi

  # Create AGENTS.md symlink if missing
  if [[ ! -L "$ws/AGENTS.md" ]]; then
    ln -sf CLAUDE.md "$ws/AGENTS.md"
  fi
}

is_running() {
  local pf
  pf="$(pid_file "$1")"
  if [[ -f "$pf" ]]; then
    local pid
    pid="$(cat "$pf")"
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

read_pid() {
  cat "$(pid_file "$1")" 2>/dev/null || echo ""
}

required_clis_for_loop_type() {
  local loop_type="$1"
  case "$loop_type" in
    slow) echo "claude codex" ;;
    yolo) echo "claude" ;;
    yolo-codex|yolo-codex-spark) echo "codex" ;;
    *) echo "" ;;
  esac
}

is_loop_type_supported_here() {
  local loop_type="$1"
  local cli
  for cli in $(required_clis_for_loop_type "$loop_type"); do
    if ! command -v "$cli" >/dev/null 2>&1; then
      return 1
    fi
  done
  return 0
}

list_supported_loop_types() {
  local -a supported=()
  local candidate
  for candidate in slow yolo yolo-codex yolo-codex-spark; do
    if is_loop_type_supported_here "$candidate"; then
      supported+=("$candidate")
    fi
  done

  if (( ${#supported[@]} == 0 )); then
    echo "none"
    return
  fi
  printf '%s' "${supported[*]}"
}

validate_loop_type_prereqs() {
  local name="$1"
  local loop_type="$2"
  local -a missing_clis=()
  local cli

  for cli in $(required_clis_for_loop_type "$loop_type"); do
    if ! command -v "$cli" >/dev/null 2>&1; then
      missing_clis+=("$cli")
    fi
  done

  if (( ${#missing_clis[@]} == 0 )); then
    return 0
  fi

  local supported_types suggestion
  supported_types="$(list_supported_loop_types)"
  suggestion=""

  if [[ "$loop_type" == "slow" ]] && is_loop_type_supported_here "yolo"; then
    suggestion="Try --type yolo (Claude-only) on this machine."
  elif [[ "$loop_type" == "slow" ]] && is_loop_type_supported_here "yolo-codex"; then
    suggestion="Try --type yolo-codex (Codex-only) on this machine."
  elif [[ "$loop_type" == "yolo-codex" || "$loop_type" == "yolo-codex-spark" ]]; then
    if is_loop_type_supported_here "yolo"; then
      suggestion="Try --type yolo (Claude) until Codex CLI is installed."
    fi
  elif [[ "$loop_type" == "yolo" ]] && is_loop_type_supported_here "yolo-codex"; then
    suggestion="Try --type yolo-codex (Codex) until Claude CLI is installed."
  fi

  echo "[subturtle:${name}] ERROR: loop type '${loop_type}' requires missing CLI(s): ${missing_clis[*]}" >&2
  echo "[subturtle:${name}] Supported loop types on this host: ${supported_types}" >&2
  if [[ -n "$suggestion" ]]; then
    echo "[subturtle:${name}] ${suggestion}" >&2
  fi
  exit 1
}

do_start() {
  local name="${1:-default}"
  local timeout_str="${DEFAULT_TIMEOUT}"
  local loop_type="yolo-codex"
  local -a skills=()

  # Parse --timeout, --type, and --skill flags from remaining args
  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout_str="${2:?missing timeout value}"; shift 2 ;;
      --type)    loop_type="${2:?missing type value}"; shift 2 ;;
      --skill)   skills+=("${2:?missing skill name}"); shift 2 ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  # Validate loop type
  case "$loop_type" in
    slow|yolo|yolo-codex|yolo-codex-spark) ;;
    *) echo "ERROR: unknown SubTurtle type '${loop_type}' (must be: slow, yolo, yolo-codex, yolo-codex-spark)" >&2; exit 1 ;;
  esac

  validate_loop_type_prereqs "$name" "$loop_type"

  local timeout_secs
  timeout_secs="$(parse_duration "$timeout_str")" || exit 1

  # Convert skills array to JSON. Guard empty arrays for bash + nounset compatibility.
  local skills_json="[]"
  if (( ${#skills[@]} > 0 )); then
    skills_json="$(
      printf '%s\n' "${skills[@]}" | "$PYTHON" -c 'import sys, json; print(json.dumps([line.strip() for line in sys.stdin if line.strip()]))' 2>/dev/null || echo '[]'
    )"
  fi

  ensure_workspace "$name"

  if is_running "$name"; then
    echo "[subturtle:${name}] already running (PID $(read_pid "$name"))"
    exit 0
  fi

  local pf lf mf ws
  pf="$(pid_file "$name")"
  lf="$(log_file "$name")"
  mf="$(meta_file "$name")"
  ws="$(workspace_dir "$name")"

  rm -f "$pf" "$mf"

  echo "[subturtle:${name}] spawning (type: ${loop_type}, timeout: ${timeout_str})..."
  echo "[subturtle:${name}] workspace: ${ws}"
  echo "[subturtle:${name}] log: ${lf}"

  # Spawn the SubTurtle module in a new session via start_new_session=True.
  # This calls os.setsid() in the child, giving it its own session
  # and process group â€” unreachable by the parent's group signals.
  # The launcher exits immediately; child process is orphaned to PID 1.
  "$PYTHON" -c "
import subprocess, sys, os, json

pid_file   = sys.argv[1]
log_file   = sys.argv[2]
python     = sys.argv[3]
cwd        = sys.argv[4]
state_dir  = sys.argv[5]
name       = sys.argv[6]
loop_type  = sys.argv[7]
skills_json = sys.argv[8] if len(sys.argv) > 8 else '[]'

try:
    skills = json.loads(skills_json)
except (ValueError, TypeError):
    skills = []

def _can_write_home(path: str | None) -> bool:
    if not path:
        return False
    try:
        os.makedirs(path, exist_ok=True)
        probe = os.path.join(path, \".subturtle-home-write-test\")
        with open(probe, \"w\", encoding=\"utf-8\") as f:
            f.write(\"ok\")
        os.remove(probe)
        return True
    except OSError:
        return False

env = os.environ.copy()
# Strip Claude Code session vars so child can spawn its own claude processes
for key in list(env):
    if key.startswith('CLAUDECODE'):
        del env[key]
# Strip ALL Codex session/sandbox vars so inner codex processes start fresh.
# Same pattern as CLAUDECODE* stripping above. The inner codex exec must
# not inherit session IDs, thread IDs, or sandbox flags from the outer
# Codex session (when the meta-agent is Codex). This prevents concurrent
# session conflicts and auth errors.
for key in list(env):
    if key.startswith('CODEX'):
        del env[key]

# Re-pin CODEX_HOME to the real ~/.codex so the inner codex finds
# auth.json and config.toml regardless of what the outer process had.
real_codex_home = os.path.join(os.path.expanduser(\"~\"), \".codex\")
if os.path.isdir(real_codex_home):
    env[\"CODEX_HOME\"] = real_codex_home

# In sandboxed runs, HOME can be read-only which makes Claude/Codex crash
# before doing any work (they write ~/.claude*, ~/.claude.json, ~/.codex, etc.).
# Fall back to a writable per-SubTurtle runtime HOME only when needed.
original_home = env.get(\"HOME\")
if not _can_write_home(original_home):
    runtime_home = os.path.join(state_dir, \".runtime-home\")
    os.makedirs(runtime_home, exist_ok=True)
    env[\"HOME\"] = runtime_home
    env[\"CLAUDE_CONFIG_DIR\"] = os.path.join(runtime_home, \".claude\")
    env[\"XDG_CONFIG_HOME\"] = os.path.join(runtime_home, \".config\")
    env[\"XDG_DATA_HOME\"] = os.path.join(runtime_home, \".local\", \"share\")
    env[\"XDG_STATE_HOME\"] = os.path.join(runtime_home, \".local\", \"state\")
    env[\"XDG_CACHE_HOME\"] = os.path.join(runtime_home, \".cache\")
    env[\"TMPDIR\"] = os.path.join(runtime_home, \".tmp\")
    for d in (
        env[\"CLAUDE_CONFIG_DIR\"],
        env[\"XDG_CONFIG_HOME\"],
        env[\"XDG_DATA_HOME\"],
        env[\"XDG_STATE_HOME\"],
        env[\"XDG_CACHE_HOME\"],
        env[\"TMPDIR\"],
    ):
        os.makedirs(d, exist_ok=True)

log_fd = open(log_file, 'w')
cmd = [python, '-u', '-m', 'super_turtle.subturtle', '--state-dir', state_dir, '--name', name, '--type', loop_type]
if skills:
    cmd.extend(['--skills'] + skills)

proc = subprocess.Popen(
    cmd,
    cwd=cwd,
    stdin=subprocess.DEVNULL,
    stdout=log_fd,
    stderr=log_fd,
    start_new_session=True,
    env=env,
)
log_fd.close()

with open(pid_file, 'w') as f:
    f.write(str(proc.pid))

print(f'[subturtle:{name}] spawned as {loop_type} (PID {proc.pid})')
" "$pf" "$lf" "$PYTHON" "$PROJECT_DIR" "$ws" "$name" "$loop_type" "$skills_json"

  # Read back the PID we just wrote
  local turtle_pid
  if [[ ! -f "$pf" ]]; then
    echo "[subturtle:${name}] ERROR: spawn failed â€” no PID file written" >&2
    exit 1
  fi
  turtle_pid="$(cat "$pf")"

  # Write metadata (spawn time + timeout + skills)
  local spawned_at
  spawned_at="$(date +%s)"
  cat > "$mf" <<METAEOF
SPAWNED_AT=${spawned_at}
TIMEOUT_SECONDS=${timeout_secs}
LOOP_TYPE=${loop_type}
SKILLS=${skills_json}
METAEOF

  # Spawn watchdog: sleeps for timeout, then kills the sub-turtle.
  # The watchdog is a fire-and-forget background process â€” no polling overhead.
  # disown ensures it survives if the launching terminal closes.
  (
    sleep "$timeout_secs"
    if kill -0 "$turtle_pid" 2>/dev/null; then
      echo "[subturtle:${name}] TIMEOUT ($(format_duration "$timeout_secs")) â€” sending SIGTERM to PID ${turtle_pid}" >> "$lf"
      kill "$turtle_pid" 2>/dev/null || true
      sleep 5
      if kill -0 "$turtle_pid" 2>/dev/null; then
        echo "[subturtle:${name}] SIGTERM didn't work â€” sending SIGKILL" >> "$lf"
        kill -9 "$turtle_pid" 2>/dev/null || true
      fi
      rm -f "$pf" "$mf"
      echo "[subturtle:${name}] timed out and killed" >> "$lf"
    fi
  ) &
  local watchdog_pid=$!
  disown "$watchdog_pid"

  # Append watchdog PID to meta
  echo "WATCHDOG_PID=${watchdog_pid}" >> "$mf"

  echo "[subturtle:${name}] watchdog armed (${timeout_str}, PID ${watchdog_pid})"
  append_run_event "$name" "spawn" "running"
}

register_spawn_cron_job() {
  local name="$1"
  local interval_ms="$2"
  local cron_jobs_file="$CRON_JOBS_FILE"

  "$PYTHON" - "$cron_jobs_file" "$name" "$interval_ms" <<'PY'
import datetime
import json
import secrets
import sys
from pathlib import Path

cron_jobs_path = Path(sys.argv[1])
name = sys.argv[2]
interval_ms = int(sys.argv[3])

prompt = (
    f"[SILENT CHECK-IN] Check SubTurtle {name}: run `./super_turtle/subturtle/ctl status {name}`, "
    f"inspect `.subturtles/{name}/CLAUDE.md`, and review `git log --oneline -10`.\n"
    "Rules: Do NOT message the user unless one of these conditions is met:\n"
    f"- ðŸŽ‰ SubTurtle completed all backlog items -> stop SubTurtle {name} and report what shipped\n"
    f"- âš ï¸ SubTurtle appears stuck (no meaningful progress across 2+ checks) -> stop it, diagnose, and report\n"
    "- âŒ SubTurtle errored, crashed, or is otherwise broken -> report the error clearly\n"
    "- ðŸš€ New milestone reached (significant backlog progress) -> send one brief update\n"
    "If SubTurtle is progressing normally without notable events, respond with only: [SILENT]"
)

jobs = []
if cron_jobs_path.exists():
    raw = cron_jobs_path.read_text(encoding="utf-8").strip()
    if raw:
        parsed = json.loads(raw)
        if not isinstance(parsed, list):
            raise ValueError("cron-jobs.json must contain a JSON array")
        jobs = parsed

existing_ids = {
    str(job.get("id"))
    for job in jobs
    if isinstance(job, dict) and "id" in job
}

job_id = ""
for _ in range(32):
    candidate = secrets.token_hex(3)
    if candidate not in existing_ids:
        job_id = candidate
        break
if not job_id:
    raise RuntimeError("failed to generate unique cron job id")

now_ms = int(datetime.datetime.now(datetime.timezone.utc).timestamp() * 1000)
job = {
    "id": job_id,
    "prompt": prompt,
    "silent": True,
    "type": "recurring",
    "fire_at": now_ms + interval_ms,
    "interval_ms": interval_ms,
    "created_at": datetime.datetime.now(datetime.timezone.utc)
    .replace(microsecond=0)
    .isoformat()
    .replace("+00:00", "Z"),
}

jobs.append(job)
cron_jobs_path.write_text(json.dumps(jobs, indent=2) + "\n", encoding="utf-8")
print(job_id)
PY
}

remove_spawn_cron_job() {
  local cron_job_id="$1"
  local cron_jobs_file="$CRON_JOBS_FILE"

  "$PYTHON" - "$cron_jobs_file" "$cron_job_id" <<'PY'
import json
import sys
from pathlib import Path

cron_jobs_path = Path(sys.argv[1])
cron_job_id = sys.argv[2]

if not cron_jobs_path.exists():
    raise FileNotFoundError(f"cron jobs file not found: {cron_jobs_path}")

raw = cron_jobs_path.read_text(encoding="utf-8").strip()
jobs = []
if raw:
    parsed = json.loads(raw)
    if not isinstance(parsed, list):
        raise ValueError("cron-jobs.json must contain a JSON array")
    jobs = parsed

new_jobs = []
removed = False
for job in jobs:
    if isinstance(job, dict) and str(job.get("id")) == cron_job_id:
        removed = True
        continue
    new_jobs.append(job)

if not removed:
    raise RuntimeError(f"cron job id not found: {cron_job_id}")

cron_jobs_path.write_text(json.dumps(new_jobs, indent=2) + "\n", encoding="utf-8")
PY
}

do_reschedule_cron() {
  local name="${1:-}"
  local interval_str="${2:-}"

  if [[ -z "$name" ]]; then
    echo "ERROR: missing SubTurtle name" >&2
    echo "Usage: ./super_turtle/subturtle/ctl reschedule-cron <name> <interval>" >&2
    exit 1
  fi

  if [[ -z "$interval_str" ]]; then
    echo "ERROR: missing interval" >&2
    echo "Usage: ./super_turtle/subturtle/ctl reschedule-cron <name> <interval>" >&2
    exit 1
  fi

  local interval_secs
  interval_secs="$(parse_duration "$interval_str")" || exit 1
  if (( interval_secs <= 0 )); then
    echo "ERROR: interval must be greater than zero" >&2
    exit 1
  fi
  local interval_ms=$(( interval_secs * 1000 ))

  CRON_JOB_ID=""
  if ! read_meta "$name"; then
    echo "ERROR: SubTurtle metadata not found for '${name}'" >&2
    exit 1
  fi
  if [[ -z "${CRON_JOB_ID:-}" ]]; then
    echo "ERROR: no CRON_JOB_ID found for SubTurtle '${name}'" >&2
    exit 1
  fi

  local py_status=0
  "$PYTHON" - "$CRON_JOBS_FILE" "$CRON_JOB_ID" "$interval_ms" <<'PY' || py_status=$?
import datetime
import json
import sys
from pathlib import Path

cron_jobs_path = Path(sys.argv[1])
cron_job_id = sys.argv[2]
interval_ms = int(sys.argv[3])

if not cron_jobs_path.exists():
    raise FileNotFoundError(f"cron jobs file not found: {cron_jobs_path}")

raw = cron_jobs_path.read_text(encoding="utf-8").strip()
jobs = []
if raw:
    parsed = json.loads(raw)
    if not isinstance(parsed, list):
        raise ValueError("cron-jobs.json must contain a JSON array")
    jobs = parsed

now_ms = int(datetime.datetime.now(datetime.timezone.utc).timestamp() * 1000)
updated = False
for job in jobs:
    if isinstance(job, dict) and str(job.get("id")) == cron_job_id:
        job["interval_ms"] = interval_ms
        job["fire_at"] = now_ms + interval_ms
        updated = True
        break

if not updated:
    sys.exit(42)

cron_jobs_path.write_text(json.dumps(jobs, indent=2) + "\n", encoding="utf-8")
PY
  if (( py_status != 0 )); then
    if (( py_status == 42 )); then
      echo "ERROR: no cron job found for id '${CRON_JOB_ID}'" >&2
    else
      echo "ERROR: failed to update cron jobs in ${CRON_JOBS_FILE_REL}" >&2
    fi
    exit 1
  fi

  echo "[subturtle:${name}] cron job ${CRON_JOB_ID} rescheduled to every ${interval_str}"
}

do_spawn() {
  local name="${1:-default}"
  local timeout_str="${DEFAULT_TIMEOUT}"
  local loop_type="yolo-codex"
  local cron_interval="10m"
  local state_file=""
  local -a skills=()

  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout_str="${2:?missing timeout value}"; shift 2 ;;
      --type)    loop_type="${2:?missing type value}"; shift 2 ;;
      --state-file) state_file="${2:?missing state file path}"; shift 2 ;;
      --cron-interval) cron_interval="${2:?missing cron interval}"; shift 2 ;;
      --skill)   skills+=("${2:?missing skill name}"); shift 2 ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local cron_interval_secs
  cron_interval_secs="$(parse_duration "$cron_interval")" || exit 1
  if (( cron_interval_secs <= 0 )); then
    echo "[subturtle:${name}] ERROR: --cron-interval must be greater than zero" >&2
    exit 1
  fi
  local cron_interval_ms=$(( cron_interval_secs * 1000 ))

  local ws
  ws="$(workspace_dir "$name")"
  mkdir -p "$ws"

  if [[ -n "$state_file" ]]; then
    if [[ "$state_file" == "-" ]]; then
      if ! cat > "$ws/CLAUDE.md"; then
        echo "[subturtle:${name}] ERROR: failed reading state from stdin" >&2
        exit 1
      fi
    else
      if [[ ! -f "$state_file" ]]; then
        echo "[subturtle:${name}] ERROR: state file not found: ${state_file}" >&2
        exit 1
      fi
      cp "$state_file" "$ws/CLAUDE.md"
    fi
  elif [[ ! -t 0 ]]; then
    if ! cat > "$ws/CLAUDE.md"; then
      echo "[subturtle:${name}] ERROR: failed reading state from stdin" >&2
      exit 1
    fi
  else
    echo "[subturtle:${name}] ERROR: missing state input (use --state-file PATH or pipe stdin)" >&2
    exit 1
  fi

  ln -sf CLAUDE.md "$ws/AGENTS.md"

  local -a start_args=("$name" --type "$loop_type" --timeout "$timeout_str")
  local skill
  if (( ${#skills[@]} > 0 )); then
    for skill in "${skills[@]}"; do
      start_args+=(--skill "$skill")
    done
  fi
  do_start "${start_args[@]}"

  local cron_job_id
  if ! cron_job_id="$(register_spawn_cron_job "$name" "$cron_interval_ms")"; then
    echo "[subturtle:${name}] ERROR: failed to register cron job in ${CRON_JOBS_FILE_REL}" >&2
    echo "[subturtle:${name}] stopping SubTurtle because cron registration failed" >&2
    if is_running "$name"; then
      do_stop "$name" >/dev/null 2>&1 || true
    fi
    exit 1
  fi

  echo "CRON_JOB_ID=${cron_job_id}" >> "$(meta_file "$name")"

  echo "[subturtle:${name}] cron registered (${cron_job_id}, every ${cron_interval})"
  echo ""
  do_list
}

do_stop() {
  local name="${1:-default}"
  local ws
  ws="$(workspace_dir "$name")"

  # Remove recurring supervision cron before stopping the process.
  CRON_JOB_ID=""
  if read_meta "$name" && [[ -n "${CRON_JOB_ID:-}" ]]; then
    if remove_spawn_cron_job "$CRON_JOB_ID"; then
      echo "[subturtle:${name}] cron job ${CRON_JOB_ID} removed"
    else
      echo "[subturtle:${name}] WARNING: failed to remove cron job ${CRON_JOB_ID}" >&2
    fi
  fi

  # Kill the watchdog first so it doesn't fire after manual stop
  WATCHDOG_PID=""
  if read_meta "$name" && [[ -n "${WATCHDOG_PID:-}" ]]; then
    kill "$WATCHDOG_PID" 2>/dev/null || true
  fi

  if ! is_running "$name"; then
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
    if [[ -d "$ws" ]]; then
      append_run_event "$name" "stop" "not_running"
    fi
    do_archive "$name"
    exit 0
  fi

  local pid
  pid="$(read_pid "$name")"
  echo "[subturtle:${name}] stopping (PID ${pid})..."

  kill "$pid" 2>/dev/null || true

  local i
  for i in $(seq 1 10); do
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "[subturtle:${name}] stopped"
      rm -f "$(pid_file "$name")" "$(meta_file "$name")"
      append_run_event "$name" "stop" "stopped"
      do_archive "$name"
      return
    fi
    sleep 1
  done

  echo "[subturtle:${name}] sending SIGKILL..."
  kill -9 "$pid" 2>/dev/null || true
  rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  echo "[subturtle:${name}] killed"
  append_run_event "$name" "stop" "killed"
  do_archive "$name"
}

do_status() {
  local name="${1:-default}"

  if is_running "$name"; then
    local pid remaining_secs
    pid="$(read_pid "$name")"

    remaining_secs="$(time_remaining "$name")"

    # Read meta for type and skills info (always attempt)
    LOOP_TYPE=""
    SKILLS=""
    read_meta "$name" || true
    local type_info="${LOOP_TYPE:-yolo-codex}"

    # Build the status line
    local time_info=""
    if [[ -n "$remaining_secs" && -n "$SPAWNED_AT" ]]; then
      local now elapsed
      now="$(date +%s)"
      elapsed=$(( now - SPAWNED_AT ))
      time_info=" â€” $(format_duration "$elapsed") elapsed, $(format_time_remaining "$remaining_secs")"
    fi

    echo "[subturtle:${name}] running as ${type_info} (PID ${pid})${time_info}"

    # Show skills if any
    if [[ -n "$SKILLS" && "$SKILLS" != "[]" ]]; then
      echo "[subturtle:${name}] skills: ${SKILLS}"
    fi

    ps -o pid,ppid,pgid,sess,state,etime,command -p "$pid" 2>/dev/null || true

    # Show tunnel URL if it exists
    local tunnel_file
    tunnel_file="$(tunnel_url_file "$name")"
    if [[ -f "$tunnel_file" ]]; then
      local tunnel_url
      tunnel_url="$(cat "$tunnel_file")"
      echo "[subturtle:${name}] tunnel URL: ${tunnel_url}"
    fi
  else
    echo "[subturtle:${name}] not running"
    rm -f "$(pid_file "$name")" "$(meta_file "$name")"
  fi
}

do_logs() {
  local name="${1:-default}"
  local lf
  lf="$(log_file "$name")"

  if [[ ! -f "$lf" ]]; then
    echo "[subturtle:${name}] no log file found at ${lf}"
    exit 1
  fi
  tail -n "${LINES:-50}" -f "$lf"
}

do_archive() {
  local name="${1:-default}"
  local ws archive_root archive_ws
  ws="$(workspace_dir "$name")"
  archive_root="${SUBTURTLES_DIR}/.archive"
  archive_ws="${archive_root}/${name}"

  if is_running "$name"; then
    echo "[subturtle:${name}] ERROR: cannot archive while running (PID $(read_pid "$name"))" >&2
    exit 1
  fi

  if [[ ! -d "$ws" ]]; then
    if [[ -d "$archive_ws" ]]; then
      echo "[subturtle:${name}] already archived at ${archive_ws}"
      return 0
    fi
    echo "[subturtle:${name}] ERROR: workspace not found at ${ws}" >&2
    exit 1
  fi

  mkdir -p "$archive_root"
  rm -rf "$archive_ws"
  mv "$ws" "$archive_ws"

  echo "[subturtle:${name}] archived to ${archive_ws}"
}

do_gc() {
  local max_age_str="1d"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --max-age)
        max_age_str="${2:?missing duration for --max-age}"
        shift 2
        ;;
      *)
        echo "ERROR: unknown option for gc: $1" >&2
        echo "Usage: ./super_turtle/subturtle/ctl gc [--max-age DURATION]" >&2
        exit 1
        ;;
    esac
  done

  local max_age_seconds
  max_age_seconds="$(parse_duration "$max_age_str")" || exit 1

  local now cutoff
  now="$(date +%s)"
  cutoff=$(( now - max_age_seconds ))

  if [[ ! -d "$SUBTURTLES_DIR" ]]; then
    return
  fi

  local ws name mtime
  for ws in "$SUBTURTLES_DIR"/*/; do
    [[ -d "$ws" ]] || continue
    name="$(basename "$ws")"

    if is_running "$name"; then
      continue
    fi

    if ! mtime="$(stat -f '%m' "$ws" 2>/dev/null)"; then
      mtime="$(stat -c '%Y' "$ws" 2>/dev/null)" || {
        echo "[subturtle:${name}] ERROR: unable to read workspace mtime" >&2
        continue
      }
    fi

    if (( mtime <= cutoff )); then
      do_archive "$name"
    fi
  done
}

do_list() {
  local show_archived=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --archived)
        show_archived=1
        shift
        ;;
      *)
        echo "ERROR: unknown option for list: $1" >&2
        echo "Usage: ./super_turtle/subturtle/ctl list [--archived]" >&2
        exit 1
        ;;
    esac
  done

  if (( show_archived == 1 )); then
    local archive_root
    archive_root="${SUBTURTLES_DIR}/.archive"
    if [[ ! -d "$archive_root" ]]; then
      echo "No archived SubTurtles found."
      return
    fi

    local archived_found=0
    local ws name archived_epoch archived_at
    for ws in "$archive_root"/*/; do
      [[ -d "$ws" ]] || continue
      name="$(basename "$ws")"
      archived_found=1

      if ! archived_epoch="$(stat -f '%c' "$ws" 2>/dev/null)"; then
        archived_epoch="$(stat -c '%Z' "$ws" 2>/dev/null || true)"
      fi

      archived_at="unknown"
      if [[ -n "$archived_epoch" ]]; then
        if ! archived_at="$(date -r "$archived_epoch" '+%Y-%m-%d %H:%M:%S' 2>/dev/null)"; then
          archived_at="$(date -d "@$archived_epoch" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")"
        fi
      fi

      printf "  %-15s %s\n" "$name" "$archived_at"
    done

    if [[ $archived_found -eq 0 ]]; then
      echo "No archived SubTurtles found."
    fi
    return
  fi

  if [[ ! -d "$SUBTURTLES_DIR" ]]; then
    echo "No SubTurtles found."
    return
  fi

  local found=0
  for ws in "$SUBTURTLES_DIR"/*/; do
    [[ -d "$ws" ]] || continue
    local name
    name="$(basename "$ws")"
    [[ "$name" == ".archive" ]] && continue
    found=1

    local status_str="stopped"
    local pid_str=""
    local time_str=""
    local type_str=""
    local skills_str=""
    local pf="${ws}subturtle.pid"
    if [[ -f "$pf" ]]; then
      local pid
      pid="$(cat "$pf")"
      if kill -0 "$pid" 2>/dev/null; then
        status_str="running"
        pid_str=" (PID ${pid})"

        # Show time remaining and loop type from meta
        local remaining_secs
        remaining_secs="$(time_remaining "$name")"
        time_str="$(format_time_remaining "$remaining_secs")"

        LOOP_TYPE=""
        SKILLS=""
        read_meta "$name" || true
        type_str="${LOOP_TYPE:-yolo-codex}"
        if [[ -n "$SKILLS" && "$SKILLS" != "[]" ]]; then
          skills_str=" [skills: ${SKILLS}]"
        fi
      fi
    fi

    # Read current task from this SubTurtle's CLAUDE.md
    local task="(no task)"
    if [[ -f "${ws}CLAUDE.md" ]]; then
      task="$(
        awk '
          /^# Current task$/ { in_current=1; next }
          in_current && /^# / { exit }
          in_current {
            line = $0
            sub(/[[:space:]]*<- current[[:space:]]*$/, "", line)
            if (line ~ /[^[:space:]]/) {
              print line
              exit
            }
          }
        ' "${ws}CLAUDE.md"
      )"
      [[ -z "$task" ]] && task="(no task)"
    fi

    if [[ -n "$time_str" ]]; then
      printf "  %-15s %-8s %-12s %-14s %-14s %s%s\n" "$name" "$status_str" "$type_str" "$pid_str" "$time_str" "$task" "$skills_str"
    else
      printf "  %-15s %-8s %-12s %-14s %-14s %s%s\n" "$name" "$status_str" "" "$pid_str" "" "$task" "$skills_str"
    fi

    # Show tunnel URL if it exists
    local tunnel_file
    tunnel_file="$(tunnel_url_file "$name")"
    if [[ -f "$tunnel_file" ]]; then
      local tunnel_url
      tunnel_url="$(cat "$tunnel_file")"
      printf "  %-15s â†’ %s\n" "" "$tunnel_url"
    fi
  done

  if [[ $found -eq 0 ]]; then
    echo "No SubTurtles found."
  fi
}

# --- Main ---
if [[ $# -lt 1 ]]; then
  usage
fi

CMD="$1"
shift

ensure_run_state_files

case "$CMD" in
  start)
    # Optional first positional arg is name. If first arg is a flag, use default.
    NAME="default"
    if [[ $# -gt 0 && "$1" != --* ]]; then
      NAME="$1"
      shift
    fi
    do_start "$NAME" "$@"
    ;;
  spawn)
    # Optional first positional arg is name. If first arg is a flag, use default.
    NAME="default"
    if [[ $# -gt 0 && "$1" != --* ]]; then
      NAME="$1"
      shift
    fi
    do_spawn "$NAME" "$@"
    ;;
  stop)   do_stop "${1:-default}" ;;
  status) do_status "${1:-default}" ;;
  logs)   do_logs "${1:-default}" ;;
  list)   do_list "$@" ;;
  archive)
    if [[ $# -ne 1 ]]; then
      echo "Usage: ./super_turtle/subturtle/ctl archive <name>" >&2
      exit 1
    fi
    do_archive "$1"
    ;;
  gc)     do_gc "$@" ;;
  reschedule-cron)
    if [[ $# -ne 2 ]]; then
      echo "Usage: ./super_turtle/subturtle/ctl reschedule-cron <name> <interval>" >&2
      exit 1
    fi
    do_reschedule_cron "$1" "$2"
    ;;
  *)      usage ;;
esac
