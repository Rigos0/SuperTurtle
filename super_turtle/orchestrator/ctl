#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
TMP_DIR="${PROJECT_DIR}/.tmp"
PID_FILE="${TMP_DIR}/orchestrator.pid"
LOG_FILE="${TMP_DIR}/orchestrator.log"

# Use orchestrator venv if available, otherwise system python3
PYTHON="${SCRIPT_DIR}/.venv/bin/python3"
if [[ ! -x "$PYTHON" ]]; then
  PYTHON="python3"
fi

usage() {
  echo "Usage: ./super_turtle/orchestrator/ctl {start|stop|status|logs}"
  echo ""
  echo "Commands:"
  echo "  start   Start the orchestrator (detached, survives session exit)"
  echo "  stop    Stop the orchestrator gracefully"
  echo "  status  Check if the orchestrator is running"
  echo "  logs    Tail the orchestrator log"
  exit 1
}

ensure_tmp() {
  mkdir -p "$TMP_DIR"
}

is_running() {
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid="$(cat "$PID_FILE")"
    if kill -0 "$pid" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

read_pid() {
  cat "$PID_FILE" 2>/dev/null || echo ""
}

do_start() {
  ensure_tmp

  if is_running; then
    echo "[orchestrator-ctl] already running (PID $(read_pid))"
    exit 0
  fi

  rm -f "$PID_FILE"

  echo "[orchestrator-ctl] starting orchestrator..."
  echo "[orchestrator-ctl] log: ${LOG_FILE}"

  # Spawn the orchestrator module in a new session via start_new_session=True.
  # This calls os.setsid() in the child, giving it its own session
  # and process group â€” unreachable by the parent's group signals.
  # The launcher exits immediately; child process is orphaned to PID 1.
  "$PYTHON" -c "
import subprocess, sys

pid_file = sys.argv[1]
log_file = sys.argv[2]
python   = sys.argv[3]
cwd      = sys.argv[4]

import os
env = os.environ.copy()
# Strip Claude Code session vars so child can spawn its own claude processes
for key in list(env):
    if key.startswith('CLAUDECODE'):
        del env[key]

log_fd = open(log_file, 'a')
proc = subprocess.Popen(
    [python, '-u', '-m', 'super_turtle.orchestrator'],
    cwd=cwd,
    stdin=subprocess.DEVNULL,
    stdout=log_fd,
    stderr=log_fd,
    start_new_session=True,
    env=env,
)
log_fd.close()

with open(pid_file, 'w') as f:
    f.write(str(proc.pid))

print(f'[orchestrator-ctl] started (PID {proc.pid})')
" "$PID_FILE" "$LOG_FILE" "$PYTHON" "$PROJECT_DIR"
}

do_stop() {
  if ! is_running; then
    echo "[orchestrator-ctl] not running"
    rm -f "$PID_FILE"
    exit 0
  fi

  local pid
  pid="$(read_pid)"
  echo "[orchestrator-ctl] stopping orchestrator (PID ${pid})..."

  kill "$pid" 2>/dev/null || true

  local i
  for i in $(seq 1 10); do
    if ! kill -0 "$pid" 2>/dev/null; then
      echo "[orchestrator-ctl] stopped"
      rm -f "$PID_FILE"
      return
    fi
    sleep 1
  done

  echo "[orchestrator-ctl] sending SIGKILL..."
  kill -9 "$pid" 2>/dev/null || true
  rm -f "$PID_FILE"
  echo "[orchestrator-ctl] killed"
}

do_status() {
  if is_running; then
    local pid
    pid="$(read_pid)"
    echo "[orchestrator-ctl] running (PID ${pid})"
    ps -o pid,ppid,pgid,sess,state,etime,command -p "$pid" 2>/dev/null || true
  else
    echo "[orchestrator-ctl] not running"
    rm -f "$PID_FILE"
  fi
}

do_logs() {
  if [[ ! -f "$LOG_FILE" ]]; then
    echo "[orchestrator-ctl] no log file found at ${LOG_FILE}"
    exit 1
  fi
  tail -n "${LINES:-50}" -f "$LOG_FILE"
}

# --- Main ---
if [[ $# -lt 1 ]]; then
  usage
fi

case "$1" in
  start)  do_start ;;
  stop)   do_stop ;;
  status) do_status ;;
  logs)   do_logs ;;
  *)      usage ;;
esac
