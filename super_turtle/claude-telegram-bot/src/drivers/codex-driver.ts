import { codexSession, mapThinkingToReasoningEffort } from "../codex-session";
import type { ChatDriver, DriverRunInput, DriverStatusSnapshot } from "./types";
import type { McpCompletionCallback } from "../types";

async function wait(ms: number): Promise<void> {
  await new Promise((resolve) => setTimeout(resolve, ms));
}

export class CodexDriver implements ChatDriver {
  readonly id = "codex" as const;
  readonly displayName = "Codex";
  readonly auditEvent = "TEXT_CODEX" as const;

  async runMessage(input: DriverRunInput): Promise<string> {
    const {
      checkPendingAskUserRequests,
      checkPendingBotControlRequests,
      checkPendingSendTurtleRequests,
    } = await import("../handlers/streaming");

    const reasoningEffort = mapThinkingToReasoningEffort(input.message);
    process.env.TELEGRAM_CHAT_ID = String(input.chatId);

    // MCP completion callback: fires when an mcp_tool_call completes
    const mcpCompletionCallback: McpCompletionCallback = async (server, tool) => {
      const normalizedTool = tool.replace(/-/g, "_");

      // Detect ask-user tool and handle inline
      if (normalizedTool === "ask_user") {
        console.log("Ask-user tool completed, checking for pending requests");
        // Small delay to let MCP server write the file
        await new Promise((resolve) => setTimeout(resolve, 200));

        // Retry a few times in case of timing issues
        for (let attempt = 0; attempt < 3; attempt++) {
          const buttonsSent = await checkPendingAskUserRequests(
            input.ctx,
            input.chatId
          );
          if (buttonsSent) {
            console.log("Ask-user buttons sent, ask_user triggered");
            return true; // Signal to break event loop
          }
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        }
      }

      // Detect send-turtle tool and handle inline
      if (normalizedTool === "send_turtle") {
        console.log("Send-turtle tool completed, checking for pending requests");
        // Small delay to let MCP server write the file
        await new Promise((resolve) => setTimeout(resolve, 200));

        // Retry a few times in case of timing issues
        for (let attempt = 0; attempt < 3; attempt++) {
          const photoSent = await checkPendingSendTurtleRequests(
            input.ctx,
            input.chatId
          );
          if (photoSent) break;
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        }
      }

      // Detect bot-control tool and handle inline
      if (normalizedTool === "bot_control") {
        console.log("Bot-control tool completed, checking for pending requests");
        // Small delay to let MCP server write the file
        await new Promise((resolve) => setTimeout(resolve, 200));

        // Retry a few times in case of timing issues
        for (let attempt = 0; attempt < 3; attempt++) {
          const handled = await checkPendingBotControlRequests(
            codexSession,
            input.chatId
          );
          if (handled) break;
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        }
      }

      return false; // Only ask-user triggers event loop break
    };

    let keepPolling = true;
    const pendingPump = (async () => {
      while (keepPolling) {
        try {
          await checkPendingAskUserRequests(input.ctx, input.chatId);
          await checkPendingSendTurtleRequests(input.ctx, input.chatId);
          await checkPendingBotControlRequests(codexSession, input.chatId);
        } catch (error) {
          console.warn("Failed to process pending Codex MCP request:", error);
        }
        if (keepPolling) {
          await wait(100);
        }
      }
    })();

    let response: string;
    try {
      response = await codexSession.sendMessage(
        input.message,
        input.statusCallback,
        undefined,
        reasoningEffort,
        mcpCompletionCallback
      );
    } finally {
      keepPolling = false;
      await pendingPump;
    }

    // Final flush for late writes near turn completion.
    // Wait longer (300ms) and retry multiple times in case MCP server is still writing.
    await wait(300);
    for (let attempt = 0; attempt < 3; attempt++) {
      await checkPendingAskUserRequests(input.ctx, input.chatId);
      await checkPendingSendTurtleRequests(input.ctx, input.chatId);
      await checkPendingBotControlRequests(codexSession, input.chatId);
      if (attempt < 2) {
        await wait(100);
      }
    }

    return response;
  }

  async stop() {
    const result = await codexSession.stop();
    if (result) {
      await Bun.sleep(100);
    }
    return result;
  }

  async kill(): Promise<void> {
    await codexSession.kill();
  }

  isCrashError(error: unknown): boolean {
    const errorStr = String(error).toLowerCase();
    return errorStr.includes("crashed") || errorStr.includes("failed");
  }

  isStallError(error: unknown): boolean {
    const errorStr = String(error).toLowerCase();
    return errorStr.includes("stream stalled") || errorStr.includes("event stream stalled");
  }

  isCancellationError(error: unknown): boolean {
    const errorStr = String(error).toLowerCase();
    return errorStr.includes("abort") || errorStr.includes("cancel");
  }

  getStatusSnapshot(): DriverStatusSnapshot {
    return {
      driverName: "Codex",
      isActive: codexSession.isActive,
      sessionId: codexSession.getThreadId(),
      lastActivity: codexSession.lastActivity,
      lastError: codexSession.lastError,
      lastErrorTime: codexSession.lastErrorTime,
      lastUsage: codexSession.lastUsage
        ? {
            inputTokens: codexSession.lastUsage.input_tokens || 0,
            outputTokens: codexSession.lastUsage.output_tokens || 0,
          }
        : null,
    };
  }
}
