<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake Speedrun</title>
    <style>
      :root {
        --bg: #06090f;
        --panel: #0a1222;
        --text: #e6f2ff;
        --accent: #19f96b;
        --accent-soft: rgba(25, 249, 107, 0.2);
        --accent-rgb: 25, 249, 107;
        --canvas: #050d18;
        --scan: rgba(255, 255, 255, 0.08);
      }
      html,
      body {
        margin: 0;
        min-height: 100%;
        background:
          repeating-linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.03) 0,
            rgba(255, 255, 255, 0.03) 1px,
            transparent 1px,
            transparent 3px
          ),
          radial-gradient(circle at top left, #1a2f50 0, transparent 45%),
          var(--bg);
        color: var(--text);
        font-family:
          "Share Tech Mono",
          "VT323",
          ui-monospace,
          SFMono-Regular,
          Menlo,
          monospace;
        line-height: 1.25;
      }
      .wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: clamp(0.8rem, 2.2vw, 1.5rem);
        box-sizing: border-box;
      }
      .card {
        width: min(880px, 100%);
        border: 1px solid rgba(var(--accent-rgb), 0.35);
        border-radius: 16px;
        position: relative;
        background:
          linear-gradient(160deg, rgba(10, 18, 34, 0.95), rgba(8, 15, 31, 0.92)),
          linear-gradient(rgba(var(--accent-rgb), 0.12), rgba(var(--accent-rgb), 0) 40%);
        box-shadow:
          0 28px 80px rgba(2, 6, 18, 0.55),
          inset 0 0 0 1px rgba(var(--accent-rgb), 0.28),
          0 0 24px rgba(var(--accent-rgb), 0.16);
        padding: clamp(0.85rem, 2vw, 1.35rem);
      }
      .card::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 16px;
        background: linear-gradient(
          transparent 0,
          rgba(255, 255, 255, 0.02) 50%,
          transparent 100%
        );
        pointer-events: none;
      }
      .title {
        margin: 0 0 0.3rem;
        font-size: clamp(1.5rem, 3.6vw, 2.2rem);
        letter-spacing: 0.14em;
        text-transform: uppercase;
        text-shadow: 0 0 12px rgba(var(--accent-rgb), 0.45);
      }
      .score-display {
        margin: 0 0 0.8rem;
        font-size: clamp(1rem, 2vw, 1.25rem);
        color: rgba(230, 240, 255, 0.9);
        text-align: left;
        letter-spacing: 0.04em;
      }
      .stage {
        width: 100%;
        aspect-ratio: 1 / 1;
        max-height: 70vh;
        border-radius: 12px;
        border: 1px solid rgba(var(--accent-rgb), 0.3);
        background:
          linear-gradient(180deg, rgba(8, 15, 32, 0.85), rgba(4, 9, 18, 0.94)),
          var(--canvas);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        padding: 0.5rem;
        box-shadow:
          inset 0 0 0 1px rgba(255, 255, 255, 0.07),
          0 12px 34px rgba(0, 0, 0, 0.35);
        margin-bottom: 0.8rem;
      }
      canvas {
        width: min(75vw, 420px);
        height: min(75vw, 420px);
        border-radius: 8px;
        border: 1px dashed rgba(var(--accent-rgb), 0.35);
        background: rgba(4, 10, 22, 0.9);
        image-rendering: pixelated;
        box-shadow: inset 0 0 0 1px rgba(var(--accent-rgb), 0.16);
        max-width: 100%;
      }
      .hud {
        margin-top: 0.9rem;
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
        color: rgba(233, 239, 255, 0.9);
        align-items: center;
      }
      .pill {
        border: 1px solid rgba(var(--accent-rgb), 0.4);
        background: var(--accent-soft);
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .controls-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        flex-wrap: wrap;
        width: 100%;
      }
      .button {
        border: 1px solid rgba(var(--accent-rgb), 0.6);
        background: linear-gradient(
          180deg,
          rgba(var(--accent-rgb), 0.22),
          rgba(8, 17, 30, 0.8)
        );
        color: var(--text);
        cursor: pointer;
        border-radius: 999px;
        padding: 0.55rem 1rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-weight: 700;
      }
      .button:active {
        transform: translateY(1px);
      }
      .button:hover {
        background: linear-gradient(
          180deg,
          rgba(var(--accent-rgb), 0.3),
          rgba(12, 21, 40, 0.85)
        );
        box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.28);
      }
      .dpad-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        background: rgba(6, 9, 15, 0.5);
        padding: 0.8rem;
        border-radius: 10px;
        backdrop-filter: blur(4px);
        width: fit-content;
      }
      .dpad {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        gap: 0.3rem;
        width: 200px;
        height: 200px;
      }
      .dpad-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 56px;
        min-height: 56px;
        border: 1px solid rgba(var(--accent-rgb), 0.5);
        background: linear-gradient(
          180deg,
          rgba(var(--accent-rgb), 0.35),
          rgba(8, 17, 30, 0.7)
        );
        color: var(--accent);
        cursor: pointer;
        border-radius: 8px;
        font-size: 1.4rem;
        font-weight: bold;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        transition: all 0.1s ease;
      }
      .dpad-btn:active,
      .dpad-btn:hover {
        background: linear-gradient(
          180deg,
          rgba(var(--accent-rgb), 0.55),
          rgba(12, 21, 40, 0.95)
        );
        box-shadow: 0 0 14px rgba(var(--accent-rgb), 0.45);
        transform: translateY(-2px);
      }
      .dpad-btn:active {
        transform: translateY(0);
      }
      .dpad-up {
        grid-column: 2;
        grid-row: 1;
      }
      .dpad-left {
        grid-column: 1;
        grid-row: 2;
      }
      .dpad-down {
        grid-column: 2;
        grid-row: 3;
      }
      .dpad-right {
        grid-column: 3;
        grid-row: 2;
      }
      .dpad-hint {
        font-size: 0.75rem;
        color: rgba(230, 240, 255, 0.6);
        text-align: center;
        letter-spacing: 0.05em;
      }
      .new-game-btn {
        margin-top: 0.8rem;
        border: 1px solid rgba(25, 249, 107, 0.6);
        background: linear-gradient(
          180deg,
          rgba(25, 249, 107, 0.28),
          rgba(8, 17, 30, 0.8)
        );
        color: #19f96b;
        cursor: pointer;
        border-radius: 999px;
        padding: 0.55rem 1.2rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-weight: 700;
        font-family: "Share Tech Mono", "VT323", ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      .new-game-btn:active {
        transform: translateY(1px);
      }
      .new-game-btn:hover {
        background: linear-gradient(
          180deg,
          rgba(25, 249, 107, 0.38),
          rgba(12, 21, 40, 0.85)
        );
        box-shadow: 0 0 10px rgba(25, 249, 107, 0.4);
      }
      @media (max-width: 520px) {
        .hud {
          gap: 0.45rem;
        }
        .pill,
        .button {
          min-height: 40px;
          justify-content: center;
          text-align: center;
        }
        .hud .pill {
          flex: 1 1 140px;
        }
        .title {
          text-align: center;
          font-size: 1.45rem;
        }
        .description {
          text-align: center;
        }
        .controls-wrapper {
          gap: 0.6rem;
          margin-top: 0.6rem;
        }
        .dpad-container {
          padding: 0.6rem;
        }
        .dpad {
          width: 160px;
          height: 160px;
        }
        .dpad-btn {
          min-width: 48px;
          min-height: 48px;
          font-size: 1.1rem;
        }
        .button {
          padding: 0.55rem 1rem;
          font-size: 0.85rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <section class="card">
        <h1 class="title">Snake Speedrun</h1>
        <div class="score-display" id="score-display">P1: 0 | P2: 0</div>
        <div class="stage">
          <canvas id="board" width="480" height="480" aria-label="Snake game board placeholder"></canvas>
        </div>
        <div class="controls-wrapper">
          <div class="dpad-container">
            <div class="dpad">
              <button class="dpad-btn dpad-up" id="dpad-up" aria-label="Up">‚Üë</button>
              <button class="dpad-btn dpad-left" id="dpad-left" aria-label="Left">‚Üê</button>
              <button class="dpad-btn dpad-down" id="dpad-down" aria-label="Down">‚Üì</button>
              <button class="dpad-btn dpad-right" id="dpad-right" aria-label="Right">‚Üí</button>
            </div>
            <button class="new-game-btn" id="new-game-btn" aria-label="New Game" style="display:none;">New Game</button>
          </div>
        </div>
      </section>
    </main>
    <script>
      const canvas = document.getElementById("board");
      const context = canvas.getContext("2d");
      const scoreDisplay = document.getElementById("score-display");
      const dpadUpBtn = document.getElementById("dpad-up");
      const dpadLeftBtn = document.getElementById("dpad-left");
      const dpadDownBtn = document.getElementById("dpad-down");
      const dpadRightBtn = document.getElementById("dpad-right");
      const newGameBtn = document.getElementById("new-game-btn");

      let touchStartX = 0;
      let touchStartY = 0;

      const CELL_COUNT = 24;
      const CELL_SIZE = canvas.width / CELL_COUNT;

      let ws = null;
      let playerId = null;
      let gameState = {
        player1Snake: [],
        player2Snake: [],
        food: { x: 10, y: 10 },
        player1Score: 0,
        player2Score: 0,
        isRunning: false,
        isGameOver: false,
        countdown: null,
        winner: null,
      };

      let tongueOutP1 = false;
      let tongueOutP2 = false;

      function connectWebSocket() {
        const protocol = location.protocol === "https:" ? "wss:" : "ws:";
        ws = new WebSocket(`${protocol}//${location.host}`);

        ws.onopen = () => {
          render();
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.spectator) {
            return;
          }
          if (data.type === "assigned") {
            playerId = data.playerId;
            return;
          }
          gameState = data;
          render();
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        ws.onclose = () => {
          setTimeout(connectWebSocket, 3000);
        };
      }

      function sendDirection(dx, dy) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "direction", dx, dy }));
        }
      }

      function sendNewGame() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "newGame" }));
        }
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function mixColor(start, end, t) {
        return {
          r: Math.round(start.r + (end.r - start.r) * t),
          g: Math.round(start.g + (end.g - start.g) * t),
          b: Math.round(start.b + (end.b - start.b) * t),
        };
      }

      function shiftColor(color, delta) {
        return {
          r: clamp(color.r + delta, 0, 255),
          g: clamp(color.g + delta, 0, 255),
          b: clamp(color.b + delta, 0, 255),
        };
      }

      function colorToRgba(color, alpha) {
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
      }

      function roundedRectPath(left, top, size, radius) {
        const r = Math.min(radius, size / 2);
        const right = left + size;
        const bottom = top + size;
        context.beginPath();
        context.moveTo(left + r, top);
        context.lineTo(right - r, top);
        context.arc(right - r, top + r, r, -Math.PI / 2, 0);
        context.lineTo(right, bottom - r);
        context.arc(right - r, bottom - r, r, 0, Math.PI / 2);
        context.lineTo(left + r, bottom);
        context.arc(left + r, bottom - r, r, Math.PI / 2, Math.PI);
        context.lineTo(left, top + r);
        context.arc(left + r, top + r, r, Math.PI, (Math.PI * 3) / 2);
        context.closePath();
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        } : { r: 0, g: 0, b: 0 };
      }

      function drawSnakeSegment(segment, index, totalSegments, colorHex) {
        const left = segment.x * CELL_SIZE;
        const top = segment.y * CELL_SIZE;
        const inset = CELL_SIZE * 0.08;
        const size = CELL_SIZE - inset * 2;
        const radius = CELL_SIZE * 0.28;
        const t = totalSegments <= 1 ? 0 : index / (totalSegments - 1);
        const eased = t * t * (3 - 2 * t);

        const headColor = hexToRgb(colorHex);
        const tailColor = shiftColor(headColor, -50);
        const baseColor = mixColor(headColor, tailColor, eased);
        const lightColor = shiftColor(baseColor, 24);
        const darkColor = shiftColor(baseColor, -28);
        const glowAlpha = 0.45 - eased * 0.18;

        context.save();
        context.shadowColor = colorToRgba(shiftColor(baseColor, 16), glowAlpha);
        context.shadowBlur = CELL_SIZE * (0.68 - eased * 0.18);
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;

        const fill = context.createLinearGradient(
          left + inset,
          top + inset,
          left + inset + size,
          top + inset + size
        );
        fill.addColorStop(0, colorToRgba(lightColor, 0.98));
        fill.addColorStop(0.55, colorToRgba(baseColor, 0.96));
        fill.addColorStop(1, colorToRgba(darkColor, 0.94));

        roundedRectPath(left + inset, top + inset, size, radius);
        context.fillStyle = fill;
        context.fill();

        context.shadowBlur = 0;
        context.strokeStyle = colorToRgba(shiftColor(baseColor, -52), 0.38);
        context.lineWidth = 1;
        roundedRectPath(left + inset, top + inset, size, radius);
        context.stroke();

        const shineInset = inset + CELL_SIZE * 0.12;
        const shineSize = CELL_SIZE * 0.23;
        const shineAlpha = 0.22 - eased * 0.08;
        roundedRectPath(left + shineInset, top + shineInset, shineSize, CELL_SIZE * 0.12);
        context.fillStyle = `rgba(236, 255, 206, ${shineAlpha})`;
        context.fill();

        context.restore();
      }

      function drawFood(now) {
        const left = gameState.food.x * CELL_SIZE;
        const top = gameState.food.y * CELL_SIZE;
        const centerX = left + CELL_SIZE / 2;
        const centerY = top + CELL_SIZE / 2;
        const pulse = (Math.sin(now * 0.01) + 1) / 2;
        const scale = 0.82 + pulse * 0.24;
        const size = CELL_SIZE * scale;
        const half = size / 2;
        const glowAlpha = 0.3 + pulse * 0.45;
        const borderAlpha = 0.25 + pulse * 0.2;
        const wobble = Math.sin(now * 0.005) * 0.07;

        context.save();
        context.translate(centerX, centerY);
        context.rotate(wobble);

        context.shadowColor = `rgba(255, 72, 108, ${glowAlpha})`;
        context.shadowBlur = CELL_SIZE * (0.6 + pulse * 0.5);
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;

        context.fillStyle = "#ff3b5c";
        context.fillRect(-half, -half, size, size);

        context.shadowBlur = 0;
        context.strokeStyle = `rgba(255, 255, 255, ${borderAlpha})`;
        context.lineWidth = 1;
        context.strokeRect(-half + 0.5, -half + 0.5, size - 1, size - 1);

        const highlightSize = size * 0.34;
        context.fillStyle = `rgba(255, 220, 228, ${0.22 + pulse * 0.22})`;
        context.fillRect(
          -half + size * 0.16,
          -half + size * 0.16,
          highlightSize,
          highlightSize
        );

        context.restore();
      }

      function getSnakeDirection(snake) {
        if (snake.length < 2) return { x: 0, y: 0 };
        const head = snake[0];
        const next = snake[1];
        return {
          x: head.x - next.x,
          y: head.y - next.y,
        };
      }

      function drawSnakeEyes(snake) {
        if (snake.length === 0) return;
        const direction = getSnakeDirection(snake);
        const head = snake[0];
        const headLeft = head.x * CELL_SIZE;
        const headTop = head.y * CELL_SIZE;
        const headCenterX = headLeft + CELL_SIZE / 2;
        const headCenterY = headTop + CELL_SIZE / 2;
        const eyeSocketRadius = CELL_SIZE * 0.15;
        const pupilRadius = CELL_SIZE * 0.095;
        const pupilShift = CELL_SIZE * 0.09;
        const eyeSpread = CELL_SIZE * 0.18;
        const forwardOffset = CELL_SIZE * 0.12;
        const dirX = direction.x || 0;
        const dirY = direction.y || 0;

        const eyePairCenterX = headCenterX + dirX * forwardOffset;
        const eyePairCenterY = headCenterY + dirY * forwardOffset;

        let eyeOne = { x: eyePairCenterX, y: eyePairCenterY - eyeSpread };
        let eyeTwo = { x: eyePairCenterX, y: eyePairCenterY + eyeSpread };
        if (dirY !== 0) {
          eyeOne = { x: eyePairCenterX - eyeSpread, y: eyePairCenterY };
          eyeTwo = { x: eyePairCenterX + eyeSpread, y: eyePairCenterY };
        }

        context.fillStyle = "rgba(20, 95, 50, 0.7)";
        context.beginPath();
        context.arc(eyeOne.x, eyeOne.y, eyeSocketRadius, 0, Math.PI * 2);
        context.arc(eyeTwo.x, eyeTwo.y, eyeSocketRadius, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = "#061016";
        context.beginPath();
        context.arc(eyeOne.x + dirX * pupilShift, eyeOne.y + dirY * pupilShift, pupilRadius, 0, Math.PI * 2);
        context.arc(eyeTwo.x + dirX * pupilShift, eyeTwo.y + dirY * pupilShift, pupilRadius, 0, Math.PI * 2);
        context.fill();
      }

      function drawTongue(snake, tongueOut) {
        if (!tongueOut || snake.length === 0) return;
        const direction = getSnakeDirection(snake);
        const head = snake[0];
        const headLeft = head.x * CELL_SIZE;
        const headTop = head.y * CELL_SIZE;
        const headCenterX = headLeft + CELL_SIZE / 2;
        const headCenterY = headTop + CELL_SIZE / 2;
        const dirX = direction.x || 0;
        const dirY = direction.y || 0;

        const tongueBaseX = headCenterX + dirX * (CELL_SIZE * 0.5);
        const tongueBaseY = headCenterY + dirY * (CELL_SIZE * 0.5);
        const tongueLen = CELL_SIZE * 0.4;
        const tongueTipX = tongueBaseX + dirX * tongueLen;
        const tongueTipY = tongueBaseY + dirY * tongueLen;
        const perpX = -dirY;
        const perpY = dirX;
        const forkLen = CELL_SIZE * 0.15;
        const forkSpread = CELL_SIZE * 0.12;

        context.strokeStyle = "#ff3b5c";
        context.lineWidth = Math.max(2, CELL_SIZE * 0.08);
        context.lineCap = "round";
        context.beginPath();
        context.moveTo(tongueBaseX, tongueBaseY);
        context.lineTo(tongueTipX, tongueTipY);
        context.moveTo(tongueTipX, tongueTipY);
        context.lineTo(
          tongueTipX + dirX * forkLen + perpX * forkSpread,
          tongueTipY + dirY * forkLen + perpY * forkSpread
        );
        context.moveTo(tongueTipX, tongueTipY);
        context.lineTo(
          tongueTipX + dirX * forkLen - perpX * forkSpread,
          tongueTipY + dirY * forkLen - perpY * forkSpread
        );
        context.stroke();
      }

      function render() {
        const now = Date.now();
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "rgba(4, 11, 20, 0.95)";
        context.fillRect(0, 0, canvas.width, canvas.height);

        tongueOutP1 = gameState.isRunning && now % 600 < 300;
        tongueOutP2 = gameState.isRunning && now % 600 < 300;

        // Draw grid
        for (let y = 0; y <= CELL_COUNT; y++) {
          const p = y * CELL_SIZE;
          context.strokeStyle = "rgba(25, 249, 107, 0.08)";
          context.beginPath();
          context.moveTo(0, p);
          context.lineTo(canvas.width, p);
          context.stroke();
        }
        for (let x = 0; x <= CELL_COUNT; x++) {
          const p = x * CELL_SIZE;
          context.strokeStyle = "rgba(25, 249, 107, 0.08)";
          context.beginPath();
          context.moveTo(p, 0);
          context.lineTo(p, canvas.height);
          context.stroke();
        }

        // Draw food
        drawFood(now);

        // Draw player 1 snake (green)
        gameState.player1Snake.forEach((segment, index) => {
          drawSnakeSegment(segment, index, gameState.player1Snake.length, "#19f96b");
        });

        // Draw player 2 snake (cyan)
        gameState.player2Snake.forEach((segment, index) => {
          drawSnakeSegment(segment, index, gameState.player2Snake.length, "#19d4f9");
        });

        // Draw eyes and tongue for both snakes
        drawSnakeEyes(gameState.player1Snake);
        drawTongue(gameState.player1Snake, tongueOutP1);
        drawSnakeEyes(gameState.player2Snake);
        drawTongue(gameState.player2Snake, tongueOutP2);

        // Draw status messages
        if (!gameState.isRunning && gameState.player1Snake.length > 0 && !gameState.isGameOver) {
          context.fillStyle = "rgba(233, 239, 255, 0.92)";
          context.font = "bold 20px ui-monospace, SFMono-Regular, Menlo, monospace";
          context.textAlign = "center";
          context.fillText("Waiting for players...", canvas.width / 2, canvas.height / 2);
        }

        if (gameState.countdown !== null && gameState.countdown > 0) {
          context.fillStyle = "rgba(2, 8, 16, 0.72)";
          context.fillRect(0, 40, canvas.width, canvas.height - 80);

          context.save();
          context.fillStyle = "#19f96b";
          context.font = "bold 120px ui-monospace, SFMono-Regular, Menlo, monospace";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.shadowColor = "rgba(25, 249, 107, 0.8)";
          context.shadowBlur = 30;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;

          context.fillText(gameState.countdown, canvas.width / 2, canvas.height / 2);
          context.restore();
        } else if (gameState.countdown === 0) {
          context.fillStyle = "rgba(2, 8, 16, 0.72)";
          context.fillRect(0, 40, canvas.width, canvas.height - 80);

          context.save();
          context.fillStyle = "#19f96b";
          context.font = "bold 100px ui-monospace, SFMono-Regular, Menlo, monospace";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.shadowColor = "rgba(25, 249, 107, 0.8)";
          context.shadowBlur = 30;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;

          context.fillText("GO!", canvas.width / 2, canvas.height / 2);
          context.restore();
        }

        if (gameState.isGameOver) {
          context.fillStyle = "rgba(2, 8, 16, 0.72)";
          context.fillRect(0, 40, canvas.width, canvas.height - 80);

          let message = "Game Over";
          let messageColor = "#ff6d7b";

          if (gameState.winner === "draw") {
            message = "ü§ù Draw!";
            messageColor = "#ffd700";
          } else if (playerId) {
            if (gameState.winner === playerId) {
              message = "üèÜ You Win!";
              messageColor = "#19f96b";
            } else {
              message = "üíÄ You Lose!";
              messageColor = "#ff6d7b";
            }
          }

          context.fillStyle = messageColor;
          context.font = "bold 32px ui-monospace, SFMono-Regular, Menlo, monospace";
          context.textAlign = "center";
          context.fillText(message, canvas.width / 2, canvas.height / 2 - 8);
          context.fillStyle = "#e6efff";
          context.font = "20px ui-monospace, SFMono-Regular, Menlo, monospace";
          context.fillText(`P1: ${gameState.player1Score} | P2: ${gameState.player2Score}`, canvas.width / 2, canvas.height / 2 + 24);
        }

        // Update score display
        scoreDisplay.textContent = `P1: ${gameState.player1Score} | P2: ${gameState.player2Score}`;

        // Show/hide New Game button
        if (gameState.isGameOver) {
          newGameBtn.style.display = "block";
        } else {
          newGameBtn.style.display = "none";
        }
      }

      function handleDpadClick(dx, dy) {
        sendDirection(dx, dy);
      }

      function onCanvasTouchStart(event) {
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }

      function onCanvasTouchEnd(event) {
        if (event.touches.length > 0) return;
        const touch = event.changedTouches[0];
        const touchEndX = touch.clientX;
        const touchEndY = touch.clientY;

        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        if (distance < 30) {
          return;
        }

        const absX = Math.abs(deltaX);
        const absY = Math.abs(deltaY);

        if (absX > absY) {
          handleDpadClick(deltaX > 0 ? 1 : -1, 0);
        } else {
          handleDpadClick(0, deltaY > 0 ? 1 : -1);
        }
      }

      function onKeyDown(event) {
        const key = event.key;
        const move = {
          ArrowUp: [0, -1],
          ArrowDown: [0, 1],
          ArrowLeft: [-1, 0],
          ArrowRight: [1, 0],
          w: [0, -1],
          s: [0, 1],
          a: [-1, 0],
          d: [1, 0],
        }[key];

        if (move) {
          event.preventDefault();
          handleDpadClick(move[0], move[1]);
          return;
        }
      }

      window.addEventListener("keydown", onKeyDown);

      dpadUpBtn.addEventListener("click", () => handleDpadClick(0, -1));
      dpadLeftBtn.addEventListener("click", () => handleDpadClick(-1, 0));
      dpadDownBtn.addEventListener("click", () => handleDpadClick(0, 1));
      dpadRightBtn.addEventListener("click", () => handleDpadClick(1, 0));
      newGameBtn.addEventListener("click", sendNewGame);

      canvas.addEventListener("touchstart", onCanvasTouchStart, { passive: true });
      canvas.addEventListener("touchend", onCanvasTouchEnd, { passive: true });

      connectWebSocket();
      render();
    </script>
  </body>
</html>
